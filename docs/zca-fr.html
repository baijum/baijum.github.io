<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.4.1: http://docutils.sourceforge.net/" />
<title>Zope Component Architecture</title>
<style type="text/css">

/*
:Author: Fred L. Drake, Jr.
:date: $Date: 2004/03/31 22:31:05 $
:version: $Revision: 1.7 $

This stylesheet combines some ideas from the two stylesheets
distributed with docutils and enhances them for Zope 3 documentation.
*/

@import url(default.css);

body {
  margin: 0px 1em 1em 4em;
  padding: 0px; }

h1.title {
  font-size: 150%;
  min-height: 42px; }

div.section {
  margin: 0px 0px 1.5em 0px; }

div.section h1 {
  background-color: rgb(230,230,230);
  margin-left: -2em;
  padding: 0.2em;
  padding-left: 0.35em;
  padding-top: 0.35em;
  /* This grey underline make this more visually distinctive on LCD
     monitors, which often don't have enough contrast. */
  border-right: thin solid rgb(180,180,180);
  border-bottom: thin solid rgb(180,180,180); }

div.section div.section div.section h3 {
  margin-left: -1.9em;
  margin-bottom: -0.5em; }

h1 {
  font-family: sans-serif;
  font-size: 135%; }

h2 {
  font-family: sans-serif;
  font-size: 120%; }

h3 {
  font-family: sans-serif;
  font-size: 105%; }

h4 {
  font-family: sans-serif;
  font-size: 100%; }

h5 {
  font-family: sans-serif;
  font-size: 100%; }

h6 {
  font-family: sans-serif;
  font-style: italic;
  font-size: 100%; }

hr {
  width: 75%; }

.literal .pre {
  background-color: white;
  font-family: lucidatypewriter, "lucida typewriter", sans-serif; }

.literal-block {
  border: thin solid rgb(180,180,180);
  font-family: lucidatypewriter, "lucida typewriter", monospace;
  font-size: 80%;
  padding: 0.5em; }

table.table {
  margin-left: 2em;
  margin-right: 2em; }

table.table thead {
  background-color: rgb(230,230,230); }

dt {
  font-weight: bold; }

/* docutils uses the "option" class with both "col" and "span"
   elements, so we have to be explicit here */
.option-list span.option {
  font-weight: bold; }

.option-list kbd {
  font-family: inherit; }

</style>
</head>
<body>
<div class="document" id="zope-component-architecture">
<h1 class="title">Zope Component Architecture</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr class="field"><th class="docinfo-name">Auteur:</th><td class="field-body">Baiju M</td>
</tr>
<tr><th class="docinfo-name">Version:</th>
<td>0.4.1</td></tr>
<tr class="field"><th class="docinfo-name">URL:</th><td class="field-body"><a class="reference" href="http://www.muthukadan.net/docs/zca.pdf">http://www.muthukadan.net/docs/zca.pdf</a></td>
</tr>
<tr class="field"><th class="docinfo-name">Traducteur:</th><td class="field-body">Stéphane Klein &lt;<a class="reference" href="mailto:stephane&#64;harobed.org">stephane&#64;harobed.org</a>&gt;</td>
</tr>
</tbody>
</table>
<p>Copyright (C) 2007 Baiju M &lt;baiju.m.mail AT gmail.com&gt;.</p>
<p>Chacun est autorisé à copier, distribuer et/ou modifier ce document
suivant les termes de la &quot;GNU Free Documentation License&quot;, version 1.2
ou (à votre gré) toute version ultérieur publiée par la Free Software
Foundation.</p>
<p>Le code source présent dans ce document est soumis aux conditions de
la licence Zope Public License, Version 2.1 (ZPL).</p>
<p>LE CODE SOURCE DE CE DOCUMENT EST FOURNI &quot;EN L'ETAT&quot; SANS AUCUNE
GARANTIE.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">Merci à Kent Tenney (Wisconsin, USA) et Brad Allen (Dallas, USA)
pour leurs suggestions.</p>
</div>
<div class="contents topic">
<p class="topic-title first"><a id="contents" name="contents">Contents</a></p>
<ul class="auto-toc simple">
<li><a class="reference" href="#premiers-pas" id="id15" name="id15">1&nbsp;&nbsp;&nbsp;Premiers pas</a><ul class="auto-toc">
<li><a class="reference" href="#introduction" id="id16" name="id16">1.1&nbsp;&nbsp;&nbsp;Introduction</a></li>
<li><a class="reference" href="#petit-historique" id="id17" name="id17">1.2&nbsp;&nbsp;&nbsp;Petit historique</a></li>
<li><a class="reference" href="#installation" id="id18" name="id18">1.3&nbsp;&nbsp;&nbsp;Installation</a></li>
<li><a class="reference" href="#environement-d-exp-rimentation" id="id19" name="id19">1.4&nbsp;&nbsp;&nbsp;Environement d'expérimentation</a></li>
</ul>
</li>
<li><a class="reference" href="#an-example" id="id20" name="id20">2&nbsp;&nbsp;&nbsp;An example</a><ul class="auto-toc">
<li><a class="reference" href="#id9" id="id21" name="id21">2.1&nbsp;&nbsp;&nbsp;Introduction</a></li>
<li><a class="reference" href="#procedural-approach" id="id22" name="id22">2.2&nbsp;&nbsp;&nbsp;Procedural approach</a></li>
<li><a class="reference" href="#object-oriented-approach" id="id23" name="id23">2.3&nbsp;&nbsp;&nbsp;Object oriented approach</a></li>
<li><a class="reference" href="#the-adapter-pattern" id="id24" name="id24">2.4&nbsp;&nbsp;&nbsp;The adapter pattern</a></li>
</ul>
</li>
<li><a class="reference" href="#interfaces" id="id25" name="id25">3&nbsp;&nbsp;&nbsp;Interfaces</a><ul class="auto-toc">
<li><a class="reference" href="#id10" id="id26" name="id26">3.1&nbsp;&nbsp;&nbsp;Introduction</a></li>
<li><a class="reference" href="#declaring-interfaces" id="id27" name="id27">3.2&nbsp;&nbsp;&nbsp;Declaring interfaces</a></li>
<li><a class="reference" href="#implementing-interfaces" id="id28" name="id28">3.3&nbsp;&nbsp;&nbsp;Implementing interfaces</a></li>
<li><a class="reference" href="#example-revisited" id="id29" name="id29">3.4&nbsp;&nbsp;&nbsp;Example revisited</a></li>
<li><a class="reference" href="#marker-interfaces" id="id30" name="id30">3.5&nbsp;&nbsp;&nbsp;Marker interfaces</a></li>
<li><a class="reference" href="#invariants" id="id31" name="id31">3.6&nbsp;&nbsp;&nbsp;Invariants</a></li>
</ul>
</li>
<li><a class="reference" href="#adapters" id="id32" name="id32">4&nbsp;&nbsp;&nbsp;Adapters</a><ul class="auto-toc">
<li><a class="reference" href="#implementation" id="id33" name="id33">4.1&nbsp;&nbsp;&nbsp;Implementation</a></li>
<li><a class="reference" href="#registration" id="id34" name="id34">4.2&nbsp;&nbsp;&nbsp;Registration</a></li>
<li><a class="reference" href="#querying-adapter" id="id35" name="id35">4.3&nbsp;&nbsp;&nbsp;Querying adapter</a></li>
<li><a class="reference" href="#retrieving-adapter-using-interface" id="id36" name="id36">4.4&nbsp;&nbsp;&nbsp;Retrieving adapter using interface</a></li>
<li><a class="reference" href="#adapter-pattern" id="id37" name="id37">4.5&nbsp;&nbsp;&nbsp;Adapter pattern</a></li>
</ul>
</li>
<li><a class="reference" href="#utility" id="id38" name="id38">5&nbsp;&nbsp;&nbsp;Utility</a><ul class="auto-toc">
<li><a class="reference" href="#id14" id="id39" name="id39">5.1&nbsp;&nbsp;&nbsp;Introduction</a></li>
<li><a class="reference" href="#simple-utility" id="id40" name="id40">5.2&nbsp;&nbsp;&nbsp;Simple utility</a></li>
<li><a class="reference" href="#named-utility" id="id41" name="id41">5.3&nbsp;&nbsp;&nbsp;Named utility</a></li>
<li><a class="reference" href="#factory" id="id42" name="id42">5.4&nbsp;&nbsp;&nbsp;Factory</a></li>
</ul>
</li>
<li><a class="reference" href="#advanced-adapters" id="id43" name="id43">6&nbsp;&nbsp;&nbsp;Advanced adapters</a><ul class="auto-toc">
<li><a class="reference" href="#multi-adapter" id="id44" name="id44">6.1&nbsp;&nbsp;&nbsp;Multi adapter</a></li>
<li><a class="reference" href="#subscription-adapter" id="id45" name="id45">6.2&nbsp;&nbsp;&nbsp;Subscription adapter</a></li>
<li><a class="reference" href="#handler" id="id46" name="id46">6.3&nbsp;&nbsp;&nbsp;Handler</a></li>
</ul>
</li>
<li><a class="reference" href="#zca-usage-in-zope" id="id47" name="id47">7&nbsp;&nbsp;&nbsp;ZCA usage in Zope</a><ul class="auto-toc">
<li><a class="reference" href="#zcml" id="id48" name="id48">7.1&nbsp;&nbsp;&nbsp;ZCML</a></li>
<li><a class="reference" href="#overrides" id="id49" name="id49">7.2&nbsp;&nbsp;&nbsp;Overrides</a></li>
<li><a class="reference" href="#namechooser" id="id50" name="id50">7.3&nbsp;&nbsp;&nbsp;NameChooser</a></li>
<li><a class="reference" href="#locationphysicallylocatable" id="id51" name="id51">7.4&nbsp;&nbsp;&nbsp;LocationPhysicallyLocatable</a></li>
<li><a class="reference" href="#defaultsized" id="id52" name="id52">7.5&nbsp;&nbsp;&nbsp;DefaultSized</a></li>
<li><a class="reference" href="#zopeversionutility" id="id53" name="id53">7.6&nbsp;&nbsp;&nbsp;ZopeVersionUtility</a></li>
</ul>
</li>
<li><a class="reference" href="#reference" id="id54" name="id54">8&nbsp;&nbsp;&nbsp;Reference</a><ul class="auto-toc">
<li><a class="reference" href="#attribute" id="id55" name="id55">8.1&nbsp;&nbsp;&nbsp;Attribute</a></li>
<li><a class="reference" href="#declaration" id="id56" name="id56">8.2&nbsp;&nbsp;&nbsp;Declaration</a></li>
<li><a class="reference" href="#interface" id="id57" name="id57">8.3&nbsp;&nbsp;&nbsp;Interface</a></li>
<li><a class="reference" href="#adapts" id="id58" name="id58">8.4&nbsp;&nbsp;&nbsp;adapts</a></li>
<li><a class="reference" href="#alsoprovides" id="id59" name="id59">8.5&nbsp;&nbsp;&nbsp;alsoProvides</a></li>
<li><a class="reference" href="#classimplements" id="id60" name="id60">8.6&nbsp;&nbsp;&nbsp;classImplements</a></li>
<li><a class="reference" href="#classimplementsonly" id="id61" name="id61">8.7&nbsp;&nbsp;&nbsp;classImplementsOnly</a></li>
<li><a class="reference" href="#classprovides" id="id62" name="id62">8.8&nbsp;&nbsp;&nbsp;classProvides</a></li>
<li><a class="reference" href="#componentlookuperror" id="id63" name="id63">8.9&nbsp;&nbsp;&nbsp;ComponentLookupError</a></li>
<li><a class="reference" href="#createobject" id="id64" name="id64">8.10&nbsp;&nbsp;&nbsp;createObject</a></li>
<li><a class="reference" href="#directlyprovidedby" id="id65" name="id65">8.11&nbsp;&nbsp;&nbsp;directlyProvidedBy</a></li>
<li><a class="reference" href="#directlyprovides" id="id66" name="id66">8.12&nbsp;&nbsp;&nbsp;directlyProvides</a></li>
<li><a class="reference" href="#getadapter" id="id67" name="id67">8.13&nbsp;&nbsp;&nbsp;getAdapter</a></li>
<li><a class="reference" href="#getadapterincontext" id="id68" name="id68">8.14&nbsp;&nbsp;&nbsp;getAdapterInContext</a></li>
<li><a class="reference" href="#getadapters" id="id69" name="id69">8.15&nbsp;&nbsp;&nbsp;getAdapters</a></li>
<li><a class="reference" href="#getallutilitiesregisteredfor" id="id70" name="id70">8.16&nbsp;&nbsp;&nbsp;getAllUtilitiesRegisteredFor</a></li>
<li><a class="reference" href="#getfactoriesfor" id="id71" name="id71">8.17&nbsp;&nbsp;&nbsp;getFactoriesFor</a></li>
<li><a class="reference" href="#getfactoryinterfaces" id="id72" name="id72">8.18&nbsp;&nbsp;&nbsp;getFactoryInterfaces</a></li>
<li><a class="reference" href="#getglobalsitemanager" id="id73" name="id73">8.19&nbsp;&nbsp;&nbsp;getGlobalSiteManager</a></li>
<li><a class="reference" href="#getmultiadapter" id="id74" name="id74">8.20&nbsp;&nbsp;&nbsp;getMultiAdapter</a></li>
<li><a class="reference" href="#getsitemanager" id="id75" name="id75">8.21&nbsp;&nbsp;&nbsp;getSiteManager</a></li>
<li><a class="reference" href="#getutilitiesfor" id="id76" name="id76">8.22&nbsp;&nbsp;&nbsp;getUtilitiesFor</a></li>
<li><a class="reference" href="#getutility" id="id77" name="id77">8.23&nbsp;&nbsp;&nbsp;getUtility</a></li>
<li><a class="reference" href="#handle" id="id78" name="id78">8.24&nbsp;&nbsp;&nbsp;handle</a></li>
<li><a class="reference" href="#implementedby" id="id79" name="id79">8.25&nbsp;&nbsp;&nbsp;implementedBy</a></li>
<li><a class="reference" href="#implementer" id="id80" name="id80">8.26&nbsp;&nbsp;&nbsp;implementer</a></li>
<li><a class="reference" href="#implements" id="id81" name="id81">8.27&nbsp;&nbsp;&nbsp;implements</a></li>
<li><a class="reference" href="#implementsonly" id="id82" name="id82">8.28&nbsp;&nbsp;&nbsp;implementsOnly</a></li>
<li><a class="reference" href="#moduleprovides" id="id83" name="id83">8.29&nbsp;&nbsp;&nbsp;moduleProvides</a></li>
<li><a class="reference" href="#nolongerprovides" id="id84" name="id84">8.30&nbsp;&nbsp;&nbsp;noLongerProvides</a></li>
<li><a class="reference" href="#provideadapter" id="id85" name="id85">8.31&nbsp;&nbsp;&nbsp;provideAdapter</a></li>
<li><a class="reference" href="#providehandler" id="id86" name="id86">8.32&nbsp;&nbsp;&nbsp;provideHandler</a></li>
<li><a class="reference" href="#providesubscriptionadapter" id="id87" name="id87">8.33&nbsp;&nbsp;&nbsp;provideSubscriptionAdapter</a></li>
<li><a class="reference" href="#provideutility" id="id88" name="id88">8.34&nbsp;&nbsp;&nbsp;provideUtility</a></li>
<li><a class="reference" href="#providedby" id="id89" name="id89">8.35&nbsp;&nbsp;&nbsp;providedBy</a></li>
<li><a class="reference" href="#queryadapter" id="id90" name="id90">8.36&nbsp;&nbsp;&nbsp;queryAdapter</a></li>
<li><a class="reference" href="#queryadapterincontext" id="id91" name="id91">8.37&nbsp;&nbsp;&nbsp;queryAdapterInContext</a></li>
<li><a class="reference" href="#querymultiadapter" id="id92" name="id92">8.38&nbsp;&nbsp;&nbsp;queryMultiAdapter</a></li>
<li><a class="reference" href="#queryutility" id="id93" name="id93">8.39&nbsp;&nbsp;&nbsp;queryUtility</a></li>
<li><a class="reference" href="#registeradapter" id="id94" name="id94">8.40&nbsp;&nbsp;&nbsp;registerAdapter</a></li>
<li><a class="reference" href="#registeredadapters" id="id95" name="id95">8.41&nbsp;&nbsp;&nbsp;registeredAdapters</a></li>
<li><a class="reference" href="#registeredhandlers" id="id96" name="id96">8.42&nbsp;&nbsp;&nbsp;registeredHandlers</a></li>
<li><a class="reference" href="#registeredsubscriptionadapters" id="id97" name="id97">8.43&nbsp;&nbsp;&nbsp;registeredSubscriptionAdapters</a></li>
<li><a class="reference" href="#registeredutilities" id="id98" name="id98">8.44&nbsp;&nbsp;&nbsp;registeredUtilities</a></li>
<li><a class="reference" href="#registerhandler" id="id99" name="id99">8.45&nbsp;&nbsp;&nbsp;registerHandler</a></li>
<li><a class="reference" href="#registersubscriptionadapter" id="id100" name="id100">8.46&nbsp;&nbsp;&nbsp;registerSubscriptionAdapter</a></li>
<li><a class="reference" href="#registerutility" id="id101" name="id101">8.47&nbsp;&nbsp;&nbsp;registerUtility</a></li>
<li><a class="reference" href="#subscribers" id="id102" name="id102">8.48&nbsp;&nbsp;&nbsp;subscribers</a></li>
<li><a class="reference" href="#unregisteradapter" id="id103" name="id103">8.49&nbsp;&nbsp;&nbsp;unregisterAdapter</a></li>
<li><a class="reference" href="#unregisterhandler" id="id104" name="id104">8.50&nbsp;&nbsp;&nbsp;unregisterHandler</a></li>
<li><a class="reference" href="#unregistersubscriptionadapter" id="id105" name="id105">8.51&nbsp;&nbsp;&nbsp;unregisterSubscriptionAdapter</a></li>
<li><a class="reference" href="#unregisterutility" id="id106" name="id106">8.52&nbsp;&nbsp;&nbsp;unregisterUtility</a></li>
</ul>
</li>
</ul>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id15" id="premiers-pas" name="premiers-pas">1&nbsp;&nbsp;&nbsp;Premiers pas</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id16" id="introduction" name="introduction">1.1&nbsp;&nbsp;&nbsp;Introduction</a></h2>
<p>Le développement de logiciels de grandes tailles (grande quantité de
lignes de code...) est toujours une tâche très complexe.  L'expérience
montre que l'utilisation d'une approche orienté objet simplifie
l'analyse, la modélisation et l'implémentation de programmes
complexes. Les logiciels informatiques basés sur une architecture et
une programmation oriénté composant sont de nos jours de plus en plus
populaire. Une grande partie des langages de programmations disposent
de framework qui permettent ou simplifient la programmation orienté
composant. Certain de ces frameworks sont même compatibles avec
plusieurs langages. Parmi ces frameworks orientés composants on trouve
par exemple la technologie COM de Microsoft ou alors la technologie
XPCOM de Mozilla.</p>
<p>L'architecture composant de Zope (nommé ZCA : Zope Component
Architecture) est un framework qui permet d'écrire des programmes
orientés composants en langage Python. ZCA est très bien adapté pour
écrire des programmes Python complexes. Ce framework n'est pas limité
au serveur web d'application Zope, il peut être utilisé pour
l'écriture de tout type d'application Python, peut être même qu'il
devrait être nommé <cite>Python Component Architecture</cite> plutôt que Zope
Component Architecture.</p>
<p>ZCA dépend principalement de deux paquets:</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">zope.interface</span></tt> utilisé pour définir l'interface des
composants.</li>
<li><tt class="docutils literal"><span class="pre">zope.component</span></tt> pour réaliser les opérations d'enregistrements
et de recherches de composants.</li>
</ul>
</blockquote>
<p>ZCA dispose de tout ce qu'il faut pour utiliser efficacement des
objets Python. Les composants sont des objets réutilisables disposant
d'interface est introspectable. Un composant est un objet disposant
d'une interface implémenté par une classe ou tout autre objet
exécutable. L'implémentation d'un composant n'est pas l'élément le
plus important, ce qui compte avant tout c'est sa conformité avec le
&quot;contrat&quot; défini par son interface.  L'utilisation d'une architecture
orienté composant vous permet de diviser la compléxité d'un système à
travers de multiples composants coopératifs. L'architecture composant
de Zope vous aide à créer deux types de composants de base : des
<cite>adapter</cite> et des <cite>utility</cite>.</p>
<p>Notez bien que l'architecture composant de Zope ne vous aide pas à
écrire les composants eux-mêmes mais elle vous permet la création,
l'enregistrement et la recherche de composants.Notez aussi qu'un
composant <cite>adapter</cite> est une classe Python tout à fait normal (ou en
général une fabrique d'objet (factory)) et qu'un composant <cite>utility</cite>
est un objet Python exécutable standard.</p>
<p>L'architecture composant Zope est développé comme une partie distincte
du projet Zope 3. ZCA, comme indiqué plus tôt, est un framework
purement Python, il peut être utilisé pour développer n'importe quel
type d'application.  Actuellement à la fois Zope 3 et Zope 2 utilisent
très fortement ce framework mais il existe de nombreux autres projets
et même des applications non orientés Internet qui utilisent
l'architecture composant de Zope <a class="footnote-reference" href="#projects" id="id1" name="id1">[1]</a>.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id17" id="petit-historique" name="petit-historique">1.2&nbsp;&nbsp;&nbsp;Petit historique</a></h2>
<p>Le développement de la ZCA a débuté en 2001 dans le cadre du projet
Zope 3. Ce framework est le fruit de l'expérience aquise durant le
développement d'application d'envergure en Zope 2. Jim Fulton est le
père de ce projet. De nombreuses personnes ont participé à la
conception de ce framework, parmit eux on peut citer : Stephan
Richter, Philipp von Weitershausen, Guido van Rossum (créateur du
langage Python), Tres Seaver, Phillip J Eby et Martijn Faassen.</p>
<p>Par rapport à la version actuel, les premières versions de ZCA
disposaient de quelques composants supplémentaires : les composants
<cite>services</cite> et les composants <cite>views</cite>.  Ils ont été supprimé car les
développeurs ont réalisé que le composant <cite>utility</cite> pouvait remplacer
le composant <cite>service</cite> et le composant <cite>multi-adapter</cite> pouvait
remplacer le composant <cite>view</cite>. La ZCA comporte actuellement un nombre
réduit de type de type de composant :les <cite>utility</cite>, les <cite>adapter</cite>, les
<cite>subscribers</cite> et les <cite>handler</cite>. En fait, les composants <cite>subscriber</cite>
et <cite>handler</cite> sont tous deux des adaptateurs spécialisés.</p>
<p>Pendant le cycle de développement de Zope 3.2, Jim Fulton a proposé
une importante simplification de l'achitecture composant de Zope
<a class="footnote-reference" href="#proposal" id="id2" name="id2">[2]</a>. Parmit ces simplications, on trouve la possibilité en
passant par une interface unique de déclarer à la fois des composants
globaux et locaux.</p>
<p>Le paquet <tt class="docutils literal"><span class="pre">zope.component</span></tt> a une longue liste de dépendances, parmit
elles beaucoup ne sont pas nécessaire aux applications non Zope 3.
Pendant le PyCon 2007, Jim Fulton a ajouté à setuptools une nouvelle
fonctionnalité nommée <cite>extras_require</cite>. Elle permet de séparer les
fonctionnalités constituant le coeur de ZCA des fonctionnalités
annexes <a class="footnote-reference" href="#extras" id="id3" name="id3">[3]</a>.</p>
<p>Maintenant, le projet Zope Component Architecture est un projet
indépendant avec son propre cycle de version et son propre dépôt
Subversion. Toutefois, les bugs et problèmes sont encore traités à
l'intérieur du projet Zope 3 <a class="footnote-reference" href="#bugs" id="id4" name="id4">[4]</a>, et la liste de diffusion
zope-dev est utilisé pour les discussions liées aux développements
<a class="footnote-reference" href="#discussions" id="id5" name="id5">[5]</a>.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id18" id="installation" name="installation">1.3&nbsp;&nbsp;&nbsp;Installation</a></h2>
<p>Les paquets <tt class="docutils literal"><span class="pre">zope.component</span></tt> et <tt class="docutils literal"><span class="pre">zope.interface</span></tt> forment
ensemble le coeur de l'architecture composant de Zope. Ils fournissent
les fonctionnalités permettant de définir, déclarer et retrouver des
composants. Le paquet <tt class="docutils literal"><span class="pre">zope.component</span></tt> et ses dépendances sont
disponibles sous forme de PythonEggs dans le dépôt PyPI (Python Package
Index) <a class="footnote-reference" href="#pypi" id="id6" name="id6">[6]</a>.</p>
<p>Vous pouvez utiliser <cite>easy_install</cite> <a class="footnote-reference" href="#easyinstall" id="id7" name="id7">[7]</a> pour installer
<tt class="docutils literal"><span class="pre">zope.component</span></tt> et ses dépendances :</p>
<blockquote>
$ easy_install zope.component</blockquote>
<p>Cette commande télécharge <tt class="docutils literal"><span class="pre">zope.component</span></tt> et ses depandances depuis
le dépôt PyPI et les installe sur votre système.</p>
<p>D'une manière alternative, vous pouvez télécharger manuellement le
paquet <tt class="docutils literal"><span class="pre">zope.component</span></tt> et ses dépendances depuis PyPi puis les
installer manuellement. L'ordre d'installation des paquets vous est
donné ci-dessous. Sous Windows, vous aurais besoin du paquet binaire
de <tt class="docutils literal"><span class="pre">zope.interface</span></tt> et <tt class="docutils literal"><span class="pre">zope.proxy</span></tt>.</p>
<blockquote>
<ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">zope.interface</span></tt></li>
<li><tt class="docutils literal"><span class="pre">zope.proxy</span></tt></li>
<li><tt class="docutils literal"><span class="pre">zope.deferredimport</span></tt></li>
<li><tt class="docutils literal"><span class="pre">zope.event</span></tt></li>
<li><tt class="docutils literal"><span class="pre">zope.deprecation</span></tt></li>
<li><tt class="docutils literal"><span class="pre">zope.component</span></tt></li>
</ol>
</blockquote>
<p>Pour installer ces paquets après les avoir téléchagré, vous pouvez
utiliser la commande <tt class="docutils literal"><span class="pre">easy_install</span></tt> avec le nom des paquets comme
argument (vous pouvez aussi donner la totalité des noms des paquets
en argument sur la même ligne):</p>
<pre class="literal-block">
$ easy_install /path/to/zope.interface-3.4.x.tar.gz
$ easy_install /path/to/zope.proxy-3.4.x.tar.gz
...
</pre>
<p>Cette méthode install le framework ZCA dans votre <cite>system Python</cite>, dans
le répertoire <tt class="docutils literal"><span class="pre">site-packages</span></tt>... ce qui peut poser certain soucis.
Dans un poste présent dans la liste de diffusion Zope 3, Jim Fulton
est défavorable à l'utilisation du <cite>system Python</cite> <a class="footnote-reference" href="#systempython" id="id8" name="id8">[8]</a>
(c'est à dire à l'installation dans <tt class="docutils literal"><span class="pre">site-packages</span></tt>).</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id19" id="environement-d-exp-rimentation" name="environement-d-exp-rimentation">1.4&nbsp;&nbsp;&nbsp;Environement d'expérimentation</a></h2>
<p><tt class="docutils literal"><span class="pre">virtualenv</span></tt> et <tt class="docutils literal"><span class="pre">zc.buildout</span></tt> sont des outils qui permettent
l'installation de la ZCA dans un environement isolé. L'utilisation de
ces outils est conseillé lors l'expérimentation de code. De plus, il
est bénéfique de se familiariser avec eux car ils sont très pratiques autant
lors de la phase de développement que lors du déploiement d'applications.</p>
<p>Vous pouvez installer``virtualenv`` via <tt class="docutils literal"><span class="pre">easy_install</span></tt>:</p>
<pre class="literal-block">
$ easy_install virtualenv
</pre>
<p>Vous pouvez créez ensuite un nouvel environement comme ceci:</p>
<pre class="literal-block">
$ virtualenv myve
</pre>
<p>Cette command a pour effet de créer un nouvel environement virtuel dans le
dossier <tt class="docutils literal"><span class="pre">myve</span></tt>. Maintenant, à partir du dossier <tt class="docutils literal"><span class="pre">myve</span></tt>, vous
pouvez installer <tt class="docutils literal"><span class="pre">zope.component</span></tt> et ses dépendances en utilisant
l'exécutable <tt class="docutils literal"><span class="pre">easy_install</span></tt> qui se trouve dans le dossier
<tt class="docutils literal"><span class="pre">myve/bin</span></tt>:</p>
<pre class="literal-block">
$ cd myve
$ ./bin/easy_install zope.component
</pre>
<p>Vous pouvez maintenant importer les modules <tt class="docutils literal"><span class="pre">zope.interface</span></tt> et
<tt class="docutils literal"><span class="pre">zope.component</span></tt> a partir de votre nouvel interpréteur <tt class="docutils literal"><span class="pre">python</span></tt>
qui se trouve dans le dossier <tt class="docutils literal"><span class="pre">myve/bin</span></tt>:</p>
<pre class="literal-block">
$ ./bin/python
</pre>
<p>Cette commande vous donnera une invite de commande Python que vous
pouvez utiliser pour exécuter les codes sources de ce livre.</p>
<p>L'utilisation de la recette <tt class="docutils literal"><span class="pre">zc.recipe.egg</span></tt> du paquet
<tt class="docutils literal"><span class="pre">zc.buildout</span></tt> vous permet de créer un interpréteur python avec des
PythonEggs spécifique. Premièrement, installez <tt class="docutils literal"><span class="pre">zc.buildout</span></tt> en
utilisant la commande <tt class="docutils literal"><span class="pre">easy_install</span></tt> (Vous pouvez aussi faire cela à
l'intérieur d'un environement virtuel). Pour créer un nouveau buildout
pour expériement des PythonEggs, commencez par créer un nouveau
dossier et initialisez le en utilisant la command <tt class="docutils literal"><span class="pre">buildout</span> <span class="pre">init</span></tt>:</p>
<pre class="literal-block">
$ mkdir mybuildout
$ cd mybuildout
$ buildout init
</pre>
<p>Maintenant, le nouveau dossier <tt class="docutils literal"><span class="pre">mybuildout</span></tt> est un buildout. Le
fichier de configuration par défaut du buildout est <cite>buildout.cfg</cite>.
Après l'initilisation, il a pour contenu:</p>
<pre class="literal-block">
[buildout]
parts =
</pre>
<p>Vous pouvez le modifier comme ceci:</p>
<pre class="literal-block">
[buildout]
parts = py

[py]
recipe = zc.recipe.egg
interpreter = python
eggs = zope.component
</pre>
<p>Maintenant exécutez la commande <tt class="docutils literal"><span class="pre">buildout</span></tt> disponible dans le
dossier <tt class="docutils literal"><span class="pre">mybuildout/bin</span></tt> sans aucun argument. Cela a pour effet de
créer un nouvel interpréteur à l'intérieur du dossier
<tt class="docutils literal"><span class="pre">mybuildout/bin</span></tt>:</p>
<pre class="literal-block">
$ ./bin/buildout
$ ./bin/python
</pre>
<p>Cette commande vous donnera un invite de commande Python que vous
pourrez utiliser pour tester le code source de ce livre.</p>
<table class="docutils footnote" frame="void" id="projects" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1" name="projects">[1]</a></td><td><a class="reference" href="http://wiki.zope.org/zope3/ComponentArchitecture">http://wiki.zope.org/zope3/ComponentArchitecture</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="proposal" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2" name="proposal">[2]</a></td><td><a class="reference" href="http://wiki.zope.org/zope3/LocalComponentManagementSimplification">http://wiki.zope.org/zope3/LocalComponentManagementSimplification</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="extras" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3" name="extras">[3]</a></td><td><a class="reference" href="http://peak.telecommunity.com/DevCenter/setuptools#declaring-dependencies">http://peak.telecommunity.com/DevCenter/setuptools#declaring-dependencies</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="bugs" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4" name="bugs">[4]</a></td><td><a class="reference" href="https://bugs.launchpad.net/zope3">https://bugs.launchpad.net/zope3</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="discussions" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5" name="discussions">[5]</a></td><td><a class="reference" href="http://mail.zope.org/mailman/listinfo/zope-dev">http://mail.zope.org/mailman/listinfo/zope-dev</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="pypi" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6" name="pypi">[6]</a></td><td>Repository of Python packages: <a class="reference" href="http://pypi.python.org/pypi">http://pypi.python.org/pypi</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="easyinstall" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7" name="easyinstall">[7]</a></td><td><a class="reference" href="http://peak.telecommunity.com/DevCenter/EasyInstall">http://peak.telecommunity.com/DevCenter/EasyInstall</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="systempython" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8" name="systempython">[8]</a></td><td><a class="reference" href="http://article.gmane.org/gmane.comp.web.zope.zope3/21045">http://article.gmane.org/gmane.comp.web.zope.zope3/21045</a></td></tr>
</tbody>
</table>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id20" id="an-example" name="an-example">2&nbsp;&nbsp;&nbsp;An example</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id21" id="id9" name="id9">2.1&nbsp;&nbsp;&nbsp;Introduction</a></h2>
<p>Consider a business application for registering guests staying in a
hotel.  Python can implement this in a number of ways.  We will start
with a brief look at a procedural implementation, and then move to a
basic object oriented approach.  As we examine the object oriented
approach, we will see how we can benefit from the classic design
patterns, <cite>adapter</cite> and <cite>interface</cite>.  This will bring us into the
world of the Zope Component Architecture.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id22" id="procedural-approach" name="procedural-approach">2.2&nbsp;&nbsp;&nbsp;Procedural approach</a></h2>
<p>In any business application, data storage is very critical.  For
simplicity, this example use a Python dictionary as the storage.  Key
of the dictionary will be the unique Id for a particular guest.  And
value will be another dictionary with key as the property name:</p>
<pre class="literal-block">
&gt;&gt;&gt; guests_db = {} #key: unique Id, value: details in a dictionary
</pre>
<p>In a simplistic method, a function which accepts details as arguments
is enough to do the registration.  You also required a supporting
function to get the next Id for your data storage.</p>
<p>The supporting function, for getting the next Id can be implemented
like this:</p>
<pre class="literal-block">
&gt;&gt;&gt; def get_next_id():
...     db_keys = guests_db.keys()
...     if db_keys == []:
...         next_id = 1
...     else:
...         next_id = max(db_keys) + 1
...     return next_id
</pre>
<p>As you can see, the <cite>get_next_id</cite> function implementation is very
simple.  Well, this is not the ideal way, but it is sufficient to
explain concepts.  The function first get all keys of storage as list
and check whether it is empty or not.  If the list is empty, so no
item is stored, it return <cite>1</cite> as the next Id.  And if the list is not
empty, the next Id is calculated by adding <cite>1</cite> to the maximum value of
list.</p>
<p>The function to register guest can get next unique Id using
<cite>get_next_id</cite> function, then assign the details of guest using a
dictionary.  Here is the function to get details and store in the
database:</p>
<pre class="literal-block">
&gt;&gt;&gt; def register_guest(name, place):
...     next_id = get_next_id()
...     guests_db[next_id] = {
...     'name': name,
...     'place': place
...     }
</pre>
<p>We will end our discussion of the procedural approach here.
It will be much easier to add required features such as data
persistence, design flexibility, and code testability using objects.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id23" id="object-oriented-approach" name="object-oriented-approach">2.3&nbsp;&nbsp;&nbsp;Object oriented approach</a></h2>
<!-- ??? should this paragraph talk about "creating an object for
handling registration" or "creating a class to handle registration"? -->
<p>In object oriented methodology, you can think of a registrar object
handling the registration.  There are many advantages for creating an
object for handling registration.  Most importantly, the abstraction
provided by the registrar object makes the code easier to understand.
It offers a way to group related functionality, and can be extended
via inheritance. As features are added, such as canceling and updating
registration, the registrar object can grow to provide them, or
delegate them to another object.</p>
<p>Lets look at the implementation details of a registrar object
implemented as a class:</p>
<pre class="literal-block">
&gt;&gt;&gt; class guestRegistrar(object):
...
...     def register(self, name, place):
...         next_id = get_next_id()
...         guests_db[next_id] = {
...         'name': name,
...         'place': place
...         }
</pre>
<p>In this implementation, the registrar object (an instance of
<cite>GuestRegistrar</cite> class) is handling the registration.  With this
design, a particular registrar object can perform multiple
registrations.</p>
<p>This is how you can use the current registrar implementation:</p>
<pre class="literal-block">
&gt;&gt;&gt; registrar = GuestRegistrar()
&gt;&gt;&gt; registrar.register(&quot;Jack&quot;, &quot;Bangalore&quot;)
</pre>
<p>Requirement changes are unavoidable in any real world project.
Consider this case, after some time, a new requirement is arising: the
guests also required to provide phone number to admit them.  You will
be required to change the implementation of registrar object to
support it.</p>
<p>You can achieve this requirement by adding one argument to <cite>registrar</cite>
method and use that argument in the dictionary of values.  Here is the
new implementation for this requirement:</p>
<pre class="literal-block">
&gt;&gt;&gt; class GuestRegistrar(object):
...
...     def register(self, name, place, phone):
...         next_id = get_next_id()
...         guests_db[next_id] = {
...         'name': name,
...         'place': place,
...         'phone': phone
...         }
</pre>
<p>Other than migrating the data to new schema, now you have to change
the usage of <cite>GuestRegistrar</cite> in all places.  If you can abstract the
details of guest into an object and use it for registration, the code
changes can be minimized.  If you follow this design, you have to pass
that guest object instead of more arguments to the function.  The new
implementation with guest object will look like this:</p>
<pre class="literal-block">
&gt;&gt;&gt; class GuestRegistrar(object):
...
...     def register(self, guest):
...         next_id = get_next_id()
...         guests_db[next_id] = {
...         'name': guest.name,
...         'place': guest.place,
...         'phone': guest.phone
...         }
</pre>
<p>Well, even in this implementation you have to change code.  Code
change for requirement is unavoidable, your goal should be to minimize
changes and make it maintainable.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">You should have the courage to make any change, major or minor, at
any time.  Immediate feedback is the only way you can get the
courage.  Using automated testing, you can get the immediate
feedback and so the courage to make changes.  For more details about
this subject, you can read the book called <cite>Extreme Programming
Explained</cite> by Kent Beck.</p>
</div>
<p>By introducing the guest object, you saved some typing.  More than
that, the abstraction of guest object made the system much simpler and
easy to understand.  The better understanding leads to better
restructuring and hence maintainable code.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id24" id="the-adapter-pattern" name="the-adapter-pattern">2.4&nbsp;&nbsp;&nbsp;The adapter pattern</a></h2>
<p>In a real application, as you noted earlier, the registrar object may
have cancellation and/or updation functionalities.  Suppose there are
two more methods like, <cite>cancel_registration</cite> and
<cite>update_registration</cite>.  In the new design you will be required to pass
the guest object for each methods.  You can solve this problem by
setting guest object as an attribute of registrar object.</p>
<p>Here is the new implementation of registrar object which set guest
object as an attribute:</p>
<pre class="literal-block">
&gt;&gt;&gt; class GuestRegistrarNG(object):
...
...     def __init__(self, guest):
...         self.guest = guest
...
...     def register(self):
...         guest = self.guest
...         next_id = get_next_id()
...         guests_db[next_id] = {
...         'name': guest.name,
...         'place': guest.place,
...         'phone': guest.phone
...         }
</pre>
<p>The solution you reached is a common design pattern called, <cite>Adapter</cite>.
With this design, now you can add more methods, so more functionality,
if required.</p>
<p>In this implementation, while creating the instance you have to pass
the guest object which has the values as attributes.  Now you also
required to create separate instances of <cite>GuestRegistrarNG</cite> for each
guest object.</p>
<p>Now just step back and think differently.  Suppose you are the creator
of this software and selling it to many hotel customers.  Consider a
case where your different clients requires different storages.  For
example, one registrar might store the details in a relational
database and another one might store them in Zope Object Database
(ZODB).  It would be better if you can replace the registrar object
with another one which store guest details in a different way.  So, a
mechanism to change implementation based on some configuration would
be useful.</p>
<p>Zope component architecture provides a mechanism to replace components
based on configuration.  Using Zope component architecture you can
register components in a registry called component registry.  Later,
retrieve component based on the configuration.</p>
<p>The <cite>GuestRegistrarNG</cite> class follows, as you noted, a pattern called
<cite>Adapter</cite>.  The <cite>GuestRegistrarNG</cite> is the adapter which adapts the
guest object (adaptee).  As you can see, the adapter should contain
the component it adapts (adaptee).  This is a typical implementation
of adapter:</p>
<pre class="literal-block">
&gt;&gt;&gt; class Adapter(object):
...
...     def __init__(self, adaptee):
...         self.adaptee = adaptee
</pre>
<p>Now the adapter can make use adaptee (call its methods or access
attributes).  An adapter may adapt more than one component.  Zope
component architecture provides a mechanism to effectively use these
kind of objects.  So, which component should be used will become a
matter of configuration.</p>
<p>This is a common scenario where you want to use different objects
doing same things, but the details may change.  There are many
situations in programming where you want to use different
implementations for same type of objects.  Here is a small list of
other common scenarios:</p>
<blockquote>
<ul class="simple">
<li>A wiki engine with support for multiple markups (STX, reST, Plain
text, etc.)</li>
<li>An object browser which shows size of different types of objects.</li>
<li>Different types of output formats for text data (PDF, HTML etc.)</li>
<li>When developing an application for multiple clients, their
requirements may change.  Maintaining separate code bases of the
same application for different clients is difficult.  A better
approach would be to create reusable components and configure them
based on client-specific requirements.</li>
</ul>
</blockquote>
<p>All these examples points to situations where you want to make
applications extensible or pluggable.  Do not use <cite>adapter</cite>
components where you do not want extensibility or pluggability.</p>
<p>Zope component architecture provides <cite>adapter</cite> components to solve
these kinds of problems.  In fact, <cite>GuestRegistrarNG</cite> is an adapter
without explicit interface declaration.  This tutorial will discuss
adapters after introducing the concept of interfaces.  Interfaces are
one of the foundations of Zope components, so understanding the
concept and usage of interfaces is very important.</p>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id25" id="interfaces" name="interfaces">3&nbsp;&nbsp;&nbsp;Interfaces</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id26" id="id10" name="id10">3.1&nbsp;&nbsp;&nbsp;Introduction</a></h2>
<p><cite>Design Patterns</cite> is a classic book in software engineering by the
<cite>Gang of Four</cite> <a class="footnote-reference" href="#patternbook" id="id11" name="id11">[9]</a>.  In this book they recommend: &quot;Program
to an interface, not an implementation&quot;.  Defining formal interfaces
helps you better understand system.  Moreover interface brings you all
the benefits of ZCA.</p>
<p>Interface define the behavior and state of objects.  An interface
describes how you work with the object.  If you like metaphor, think
of interface as a <cite>contract for object</cite>.  Another metaphor which may
help is <cite>blueprint for objects</cite>.  In the code, methods and attributes
are forming the object's interface.</p>
<p>The notion of interface is very explicit in modern languages like
Java, C#, VB.NET etc.  Also these languages provide some syntax for
defining interfaces.  Python has the notion interfaces, but it is not
very explicit.  To simulate a formal definition of interfaces in C++,
<cite>Gang of Four</cite> used classes with virtual functions in <cite>Design
Patterns</cite> book.  In a similar fashion, Zope component architecture use
<tt class="docutils literal"><span class="pre">zope.interface.Interface</span></tt> inherited meta-class for defining an
interface.</p>
<p>The base of object-orientation is the communication between objects.
Messages are used for the communication between objects.  In Python,
functions, methods or any other callable can be used to handle
messages.</p>
<p>For example, consider this class:</p>
<pre class="literal-block">
&gt;&gt;&gt; class Host(object):
...
...     def goodmorning(self, name):
...         &quot;&quot;&quot;Say good morning to guests&quot;&quot;&quot;
...
...         return &quot;Good morning, %s!&quot; % name
</pre>
<p>In the above class, you defined a <cite>goodmorning</cite> method.  If you call
the <cite>goodmorning</cite> method from an object created using this class, it
will return <cite>Good morning, ...!</cite></p>
<pre class="literal-block">
&gt;&gt;&gt; host = Host()
&gt;&gt;&gt; host.goodmorning('Jack')
'Good morning, Jack!'
</pre>
<p>Here <tt class="docutils literal"><span class="pre">host</span></tt> is the actual object.  The implementation details of
this object is the class <tt class="docutils literal"><span class="pre">Host</span></tt>.  Now, how to find how the object
looks like, that is, what are the methods and attributes of the
object.  For this, either you have go through the implementation
details (<tt class="docutils literal"><span class="pre">Host</span></tt> class) of the object or a separate API documentation
<a class="footnote-reference" href="#api" id="id12" name="id12">[10]</a> will be required.</p>
<p>You can use the <tt class="docutils literal"><span class="pre">zope.interface</span></tt> package to define the interface of
objects.  For the class given above you can specify the interface like
this:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface

&gt;&gt;&gt; class IHost(Interface):
...
...     def goodmorning(guest):
...         &quot;&quot;&quot;Say good morning to guest&quot;&quot;&quot;
</pre>
<p>As you can see, the interface is defined using Python class statement.
We use (abuse?) Python's class statement to define interfaces.  To
make a class an interface, it must be inherited from
<tt class="docutils literal"><span class="pre">zope.interface.Interface</span></tt> .  The <tt class="docutils literal"><span class="pre">I</span></tt> prefix for interface name is
a convention.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id27" id="declaring-interfaces" name="declaring-interfaces">3.2&nbsp;&nbsp;&nbsp;Declaring interfaces</a></h2>
<p>You have already seen how to declare an interface using
<tt class="docutils literal"><span class="pre">zope.interface</span></tt> in previous section.  This section will explain the
concepts in detail.</p>
<p>Consider this example interface:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import Attribute

&gt;&gt;&gt; class IHost(Interface):
...     &quot;&quot;&quot;A host object&quot;&quot;&quot;
...
...     name = Attribute(&quot;&quot;&quot;Name of host&quot;&quot;&quot;)
...
...     def goodmorning(guest):
...         &quot;&quot;&quot;Say good morning to guest&quot;&quot;&quot;
</pre>
<p>The interface, <tt class="docutils literal"><span class="pre">IHost</span></tt> has two attributes, <tt class="docutils literal"><span class="pre">name</span></tt> and
<tt class="docutils literal"><span class="pre">goodmorning</span></tt>.  Recall that, at least in Python, methods are also
attributes of classes.  The <tt class="docutils literal"><span class="pre">name</span></tt> attribute is defined using
<tt class="docutils literal"><span class="pre">zope.interface.Attribute</span></tt> class.  When you add the attribute
<tt class="docutils literal"><span class="pre">name</span></tt> to the <tt class="docutils literal"><span class="pre">IHost</span></tt> interface, you don't set an initial value.
The purpose of defining the attribute <tt class="docutils literal"><span class="pre">name</span></tt> here is merely to
indicate that any implementation of this interface will feature an
attribute named <tt class="docutils literal"><span class="pre">name</span></tt>.  In this case, you don't even say what type
of attribute it has to be!.  You can pass a documentation string as a
first argument to <tt class="docutils literal"><span class="pre">Attribute</span></tt>.</p>
<p>The other attribute, <tt class="docutils literal"><span class="pre">goodmorning</span></tt> is a method defined using a
function definition.  Note that <cite>self</cite> is not required in interfaces,
because <cite>self</cite> is an implementation detail of class.  For example, a
module can implement this interface.  If a module implement this
interface, there will be a <tt class="docutils literal"><span class="pre">name</span></tt> attribute and <tt class="docutils literal"><span class="pre">goodmorning</span></tt>
function defined.  And the <tt class="docutils literal"><span class="pre">goodmorning</span></tt> function will accept one
argument.</p>
<p>Now you will see how to connect <cite>interface-class-object</cite>.  So object
is the real living thing, objects are instances of classes.  And
interface is the actual definition of the object, so classes are just
the implementation details.  This is why you should program to an
interface and not to an implementation.</p>
<p>Now you should familiarize two more terms to understand other
concepts.  First one is <cite>provide</cite> and the other one is <cite>implement</cite>.
Object provides interfaces and classes implement interfaces.  In other
words, objects provide interfaces that their classes implement.  In
the above example <tt class="docutils literal"><span class="pre">host</span></tt> (object) provides <tt class="docutils literal"><span class="pre">IHost</span></tt> (interface) and
<tt class="docutils literal"><span class="pre">Host</span></tt> (class) implement <tt class="docutils literal"><span class="pre">IHost</span></tt> (interface).  One object can
provide more than one interface also one class can implement more than
one interface.  Objects can also provide interfaces directly, in
addition to what their classes implement.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">Classes are the implementation details of objects.  In Python,
classes are callable objects, so why other callable objects can't
implement an interface.  Yes, it is possible.  For any <cite>callable
object</cite> you can declare that it produces objects that provide some
interfaces by saying that the <cite>callable object</cite> implements the
interfaces.  The <cite>callable objects</cite> are generally called as
<cite>factories</cite>.  Since functions are callable objects, a function can
be an <cite>implementer</cite> of an interface.</p>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id28" id="implementing-interfaces" name="implementing-interfaces">3.3&nbsp;&nbsp;&nbsp;Implementing interfaces</a></h2>
<p>To declare a class implements a particular interface, use the function
<tt class="docutils literal"><span class="pre">zope.interface.implements</span></tt> in the class statement.</p>
<p>Consider this example, here <tt class="docutils literal"><span class="pre">Host</span></tt> implements <tt class="docutils literal"><span class="pre">IHost</span></tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class Host(object):
...
...     implements(IHost)
...
...     name = u''
...
...     def goodmorning(self, guest):
...         &quot;&quot;&quot;Say good morning to guest&quot;&quot;&quot;
...
...         return &quot;Good morning, %s!&quot; % guest
</pre>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">If you wonder how <tt class="docutils literal"><span class="pre">implements</span></tt> function works, refer the blog post
by James Henstridge
(<a class="reference" href="http://blogs.gnome.org/jamesh/2005/09/08/python-class-advisors/">http://blogs.gnome.org/jamesh/2005/09/08/python-class-advisors/</a>) .
In the adapter section, you will see an <tt class="docutils literal"><span class="pre">adapts</span></tt> function, it is
also working similarly.</p>
</div>
<p>Since <tt class="docutils literal"><span class="pre">Host</span></tt> implements <tt class="docutils literal"><span class="pre">IHost</span></tt>, instances of <tt class="docutils literal"><span class="pre">Host</span></tt> provides
<tt class="docutils literal"><span class="pre">IHost</span></tt>.  There are some utility methods to introspect the
declarations.  The declaration can write outside the class also.  If
you don't write <tt class="docutils literal"><span class="pre">interface.implements(IHost)</span></tt> in the above example,
then after defining the class statement, you can write like this:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import classImplements
&gt;&gt;&gt; classImplements(Host, IHost)
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id29" id="example-revisited" name="example-revisited">3.4&nbsp;&nbsp;&nbsp;Example revisited</a></h2>
<p>Now, return to the example application.  Here you will see how to
define the interface of the registrar object:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface

&gt;&gt;&gt; class IRegistrar(Interface):
...     &quot;&quot;&quot;A registrar will register object's details&quot;&quot;&quot;
...
...     def register():
...         &quot;&quot;&quot;Register object's details&quot;&quot;&quot;
...
</pre>
<p>Here, first you imported <tt class="docutils literal"><span class="pre">Interface</span></tt> class from <tt class="docutils literal"><span class="pre">zope.interface</span></tt>
module.  If you define a subclass of this <tt class="docutils literal"><span class="pre">Interface</span></tt> class, it will
be an interface from Zope component architecture point of view.  An
interface can be implemented, as you already noted, in a class or any
other callable object.</p>
<p>The registrar interface defined here is <tt class="docutils literal"><span class="pre">IRegistrar</span></tt>.  The
documentation string for interface gives an idea about the object.  By
defining a method in the interface, you made a contract for the
component, that there will be a method with same name available.  For
the method definition interface, the first argument should not be
<cite>self</cite>, because an interface will never be instantiated nor will its
methods ever be called.  Instead, the interface class merely documents
what methods and attributes should appear in any normal class that
claims to implement it, and the <cite>self</cite> parameter is an implementation
detail which doesn't need to be documented.</p>
<p>As you know, an interface can also specify normal attributes:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import Attribute

&gt;&gt;&gt; class IGuest(Interface):
...
...     name = Attribute(&quot;Name of guest&quot;)
...     place = Attribute(&quot;Place of guest&quot;)
</pre>
<p>In this interface, guest object has two attributes specified with
documentation.  An interface can also specify both attributes and
methods together.  An interface can be implemented in a class, module
or any other objects.  For example a function can dynamically create
the component and return, in this case the function is an implementer
for the interface.</p>
<p>Now you know what is an interface and how to define and use it.  In
the next chapter you can see how an interface is used to define an
adapter component.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id30" id="marker-interfaces" name="marker-interfaces">3.5&nbsp;&nbsp;&nbsp;Marker interfaces</a></h2>
<p>An interface can be used to declare that a particular object belongs
to a special type.  An interface without any attribute or method is
called <cite>marker interface</cite>.</p>
<p>Here is a <cite>marker interface</cite>:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface

&gt;&gt;&gt; class ISpecialGuest(Interface):
...     &quot;&quot;&quot;A special guest&quot;&quot;&quot;
</pre>
<p>This interface can be used to declare an object is a special guest.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id31" id="invariants" name="invariants">3.6&nbsp;&nbsp;&nbsp;Invariants</a></h2>
<p>Sometimes you will be required to use some rule for your component
which involve one or more normal attributes.  These kind of rule is
called <cite>invariants</cite>.  You can use <tt class="docutils literal"><span class="pre">zope.interface.invariant</span></tt> for
setting <cite>invariants</cite> for your objects in their interface.</p>
<p>Consider a simple example, there is a <cite>person</cite> object.  A person
object has <cite>name</cite>, <cite>email</cite> and <cite>phone</cite> attributes.  How do you
implement a validation rule that says either email or phone have to
exist, but not necessarily both.</p>
<p>First you have to make a callable object, either a simple function or
callable instance of a class like this:</p>
<pre class="literal-block">
&gt;&gt;&gt; def contacts_invariant(obj):
...
...     if not (obj.email or obj.phone):
...         raise Exception(
...             &quot;At least one contact info is required&quot;)
</pre>
<p>Then define the <cite>person</cite> object's interface like this.  Use the
<tt class="docutils literal"><span class="pre">zope.interface.invariant</span></tt> function to set the invariant:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import invariant

&gt;&gt;&gt; class IPerson(Interface):
...
...     name = Attribute(&quot;Name&quot;)
...     email = Attribute(&quot;Email Address&quot;)
...     phone = Attribute(&quot;Phone Number&quot;)
...
...     invariant(contacts_invariant)
</pre>
<p>Now use <cite>validateInvariants</cite> method of the interface to validate:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class Person(object):
...     implements(IPerson)
...
...     name = None
...     email = None
...     phone = None

&gt;&gt;&gt; jack = Person()
&gt;&gt;&gt; jack.email = u&quot;jack&#64;some.address.com&quot;
&gt;&gt;&gt; IPerson.validateInvariants(jack)
&gt;&gt;&gt; jill = Person()
&gt;&gt;&gt; IPerson.validateInvariants(jill)
Traceback (most recent call last):
...
Exception: At least one contact info is required
</pre>
<p>As you can see <cite>jack</cite> object validated without raising any
exception. But <cite>jill</cite> object didn't validated the invariant
constraint, so it raised exception.</p>
<table class="docutils footnote" frame="void" id="patternbook" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11" name="patternbook">[9]</a></td><td><a class="reference" href="http://en.wikipedia.org/wiki/Design_Patterns">http://en.wikipedia.org/wiki/Design_Patterns</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="api" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12" name="api">[10]</a></td><td><a class="reference" href="http://en.wikipedia.org/wiki/Application_programming_interface">http://en.wikipedia.org/wiki/Application_programming_interface</a></td></tr>
</tbody>
</table>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id32" id="adapters" name="adapters">4&nbsp;&nbsp;&nbsp;Adapters</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id33" id="implementation" name="implementation">4.1&nbsp;&nbsp;&nbsp;Implementation</a></h2>
<p>This section will describe adapters in detail.  Zope component
architecture, as you noted, helps to effectively use Python objects.
Adapter components are one of the basic components used by Zope
component architecture for effectively using Python objects.  Adapter
components are Python objects, but with well defined interface.</p>
<p>To declare a class is an adapter use <cite>adapts</cite> function defined in
<tt class="docutils literal"><span class="pre">zope.component</span></tt> package.  Here is a new <cite>GuestRegistrarNG</cite> adapter
with explicit interface declaration:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import implements
&gt;&gt;&gt; from zope.component import adapts

&gt;&gt;&gt; class GuestRegistrarNG(object):
...
...     implements(IRegistrar)
...     adapts(IGuest)
...
...     def __init__(self, guest):
...         self.guest = guest
...
...     def register(self):
...         guest = self.guest
...         next_id = get_next_id()
...         guests_db[next_id] = {
...         'name': guest.name,
...         'place': guest.place,
...         'phone': guest.phone
...         }
</pre>
<p>What you defined here is an <cite>adapter</cite> for <cite>IRegistrar</cite>, which adapts
<cite>IGuest</cite> object.  The <cite>IRegistrar</cite> interface is implemented by
<cite>GuestRegistrarNG</cite> class.  So, an instance of this class will provide
<cite>IRegistrar</cite> interface.</p>
<pre class="literal-block">
&gt;&gt;&gt; class Guest(object):
...
...     implements(IGuest)
...
...     def __init__(self, name, place):
...         self.name = name
...         self.place = place

&gt;&gt;&gt; jack = Guest(&quot;Jack&quot;, &quot;Bangalore&quot;)
&gt;&gt;&gt; jack_registrar = GuestRegistrarNG(jack)

&gt;&gt;&gt; IRegistrar.providedBy(jack_registrar)
True
</pre>
<p>The <cite>GuestRegistrarNG</cite> is just one adapter you created, you can also
create other adapters which handles guest registration differently.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id34" id="registration" name="registration">4.2&nbsp;&nbsp;&nbsp;Registration</a></h2>
<p>To use this adapter component, you have to register this in a
component registry also known as site manager.  A site manager
normally resides in a site.  A site and site manager will be more
important when developing a Zope 3 application.  For now you only
required to bother about global site and global site manager ( or
component registry).  A global site manager will be in memory, but a
local site manager is persistent.</p>
<p>To register your component, first get the global site manager:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()
&gt;&gt;&gt; gsm.registerAdapter(GuestRegistrarNG,
...                     (IGuest,), IRegistrar, 'ng')
</pre>
<p>To get the global site manager, you have to call
<tt class="docutils literal"><span class="pre">getGlobalSiteManager</span></tt> function available in <tt class="docutils literal"><span class="pre">zope.component</span></tt>
package.  In fact, the global site manager is available as an
attribute (<tt class="docutils literal"><span class="pre">globalSiteManager</span></tt>) of <tt class="docutils literal"><span class="pre">zope.component</span></tt> package.  So,
you can directly use <tt class="docutils literal"><span class="pre">zope.component.globalSiteManager</span></tt> attribute.
To register the adapter in component, as you can see above, use
<tt class="docutils literal"><span class="pre">registerAdapter</span></tt> method of component registry.  The first argument
should be your adapter class/factory.  The second argument is a tuple
of <cite>adaptee</cite> objects, i.e, the object which you are adapting.  In this
example, you are adapting only <cite>IGuest</cite> object.  The third argument is
the interface provided by the adapter component.  The fourth argument
is optional, that is the name of the particular adapter.  Since you
gave a name for this adapter, this is a <cite>named adapter</cite>.  If name is
not given, it will default to an empty string ('').</p>
<p>In the above registration, you have given the adaptee interface and
interface to be provided by the adapter.  Since you have already given
these details in adapter implementation, it is not required to specify
again.  In fact, you could have done the registration like this:</p>
<pre class="literal-block">
&gt;&gt;&gt; gsm.registerAdapter(GuestRegistrarNG, name='ng')
</pre>
<p>There are some old API to do the registration, which you should avoid.
The old API functions starts with <cite>provide</cite>, eg: <tt class="docutils literal"><span class="pre">provideAdapter</span></tt>,
<tt class="docutils literal"><span class="pre">provideUtility</span></tt> etc.  While developing a Zope 3 application you can
use Zope configuration markup language (ZCML) for registration of
components.  In Zope 3, local components (persistent components) can
be registered from Zope Management Interface (ZMI) or you can do it
programmatically also.</p>
<p>You registered <cite>GuestRegistrarNG</cite> with a name <cite>ng</cite>.  Similarly you can
register other adapters with different names.  If a component is
registered without name, it will default to an empty string.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">Local components are persistent components but global components are
in memory.  Global components will be registered based on the
configuration of application.  Local components are taken to memory
from database while starting the application.</p>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id35" id="querying-adapter" name="querying-adapter">4.3&nbsp;&nbsp;&nbsp;Querying adapter</a></h2>
<p>Retrieving registered components from component registry is achieved
through two functions available in <tt class="docutils literal"><span class="pre">zope.component</span></tt> package.  One of
them is <tt class="docutils literal"><span class="pre">getAdapter</span></tt> and the other is <tt class="docutils literal"><span class="pre">queryAdapter</span></tt> .  Both
functions accepts same arguments.  The <tt class="docutils literal"><span class="pre">getAdapter</span></tt> will raise
<tt class="docutils literal"><span class="pre">ComponentLookupError</span></tt> if component lookup fails on the other hand
<tt class="docutils literal"><span class="pre">queryAdapter</span></tt> will return <cite>None</cite>.</p>
<p>You can import the methods like this:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.component import getAdapter
&gt;&gt;&gt; from zope.component import queryAdapter
</pre>
<p>In the previous section you have registered a component for guest
object (adaptee) which provides <cite>IRegistrar</cite> interface with name as
'ng'.  In the first section of this chapter, you have created a guest
object named <cite>jack</cite> .</p>
<p>This is how you can retrieve a component which adapts the interface of
<cite>jack</cite> object (<cite>IGuest</cite>) and provides <cite>IRegistrar</cite> interface also with
name as 'ng'.  Here both <tt class="docutils literal"><span class="pre">getAdapter</span></tt> and <tt class="docutils literal"><span class="pre">queryAdapter</span></tt> works
similarly:</p>
<pre class="literal-block">
&gt;&gt;&gt; getAdapter(jack, IRegistrar, 'ng') #doctest: +ELLIPSIS
&lt;GuestRegistrarNG object at ...&gt;
&gt;&gt;&gt; queryAdapter(jack, IRegistrar, 'ng') #doctest: +ELLIPSIS
&lt;GuestRegistrarNG object at ...&gt;
</pre>
<p>As you can see, the first argument should be adaptee then, the
interface which should be provided by component and last the name of
adapter component.</p>
<p>If you try to lookup the component with an name not used for
registration but for same adaptee and interface, the lookup will fail.
Here is how the two methods works in such a case:</p>
<pre class="literal-block">
&gt;&gt;&gt; getAdapter(jack, IRegistrar, 'not-exists') #doctest: +ELLIPSIS
Traceback (most recent call last):
...
ComponentLookupError: ...
&gt;&gt;&gt; reg = queryAdapter(jack,
...           IRegistrar, 'not-exists') #doctest: +ELLIPSIS
&gt;&gt;&gt; reg is None
True
</pre>
<p>As you can see above, <tt class="docutils literal"><span class="pre">getAdapter</span></tt> raised a <tt class="docutils literal"><span class="pre">ComponentLookupError</span></tt>
exception, but <tt class="docutils literal"><span class="pre">queryAdapter</span></tt> returned <cite>None</cite> when lookup failed.</p>
<p>The third argument, the name of registration, is optional.  If the
third argument is not given it will default to empty string ('').
Since there is no component registered with an empty string,
<tt class="docutils literal"><span class="pre">getAdapter</span></tt> will raise <tt class="docutils literal"><span class="pre">ComponentLookupError</span></tt> .  Similarly
<tt class="docutils literal"><span class="pre">queryAdapter</span></tt> will return <cite>None</cite>, see yourself how it works:</p>
<pre class="literal-block">
&gt;&gt;&gt; getAdapter(jack, IRegistrar) #doctest: +ELLIPSIS
Traceback (most recent call last):
...
ComponentLookupError: ...
&gt;&gt;&gt; reg = queryAdapter(jack, IRegistrar) #doctest: +ELLIPSIS
&gt;&gt;&gt; reg is None
True
</pre>
<p>In this section you have learned how to register a simple adapter and
how to retrieve it from component registry.  These kind of adapters is
called single adapter, because it adapts only one adaptee.  If an
adapter adapts more that one adaptee, then it is called multi
adapter.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id36" id="retrieving-adapter-using-interface" name="retrieving-adapter-using-interface">4.4&nbsp;&nbsp;&nbsp;Retrieving adapter using interface</a></h2>
<p>Adapters can be directly retrieved using interfaces, but it will only
work for non-named single adapters.  The first argument is the adaptee
and the second argument is a keyword argument.  If adapter lookup
fails, second argument will be returned.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; IRegistrar(jack, alternate='default-output')
'default-output'
</pre>
<p>Keyword name can be omitted:</p>
<pre class="doctest-block">
&gt;&gt;&gt; IRegistrar(jack, 'default-output')
'default-output'
</pre>
<p>If second argument is not given, it will raise <cite>TypeError</cite>:</p>
<pre class="doctest-block">
&gt;&gt;&gt; IRegistrar(jack) #doctest: +NORMALIZE_WHITESPACE +ELLIPSIS
Traceback (most recent call last):
...
TypeError: ('Could not adapt',
  &lt;Guest object at ...&gt;,
  &lt;InterfaceClass __builtin__.IRegistrar&gt;)
</pre>
<p>Here <cite>GuestRegistrarNG</cite> is registered without name:</p>
<pre class="doctest-block">
&gt;&gt;&gt; gsm.registerAdapter(GuestRegistrarNG)
</pre>
<p>Now the adapter lookup should succeed:</p>
<pre class="doctest-block">
&gt;&gt;&gt; IRegistrar(jack, 'default-output') #doctest: +ELLIPSIS
&lt;GuestRegistrarNG object at ...&gt;
</pre>
</blockquote>
<p>For simple cases, you may use interface to get adapter components.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id37" id="adapter-pattern" name="adapter-pattern">4.5&nbsp;&nbsp;&nbsp;Adapter pattern</a></h2>
<p>The adapter concept in Zope Component Architecture and the classic
<cite>adapter pattern</cite> as described in Design Patterns book are very
similar.  But the intent of ZCA adapter usage is more wider than the
<cite>adapter pattern</cite> itself.  The intent of <cite>adapter pattern</cite> is to
convert the interface of a class into another interface clients
expect.  This allows classes work together that couldn't otherwise
because of incompatible interfaces.  But in the <cite>motivation</cite> section
of Degisgn Patterns book, GoF says: &quot;Often the adapter is responsible
for functionality the adapted class doesn't provide&quot;.  ZCA adapter has
more focus on adding functionalities than creating a new interface for
an adapted object (adaptee).  ZCA adapter lets adapter classes extend
functionality by adding methods.  (It would be interesting to note
that <cite>Adapter</cite> was known as <cite>Feature</cite> in earlier stage of ZCA
design. ) <a class="footnote-reference" href="#feature" id="id13" name="id13">[11]</a></p>
<p>The above paragraph has a quote from Gang of Four book, it ends like
this: &quot; ...adapted class doesn't provide&quot;.  But in the next sentence I
used &quot;adapted object&quot; instead of &quot;adapted class&quot;, because GoF
describes about two variants of adapters based on implementations.
The first one is called <cite>class adapter</cite> and the other one is called
<cite>object adapter</cite>.  A class adapter uses multiple inheritance to adapt
one interface to another, on the other hand an object adapter relies
on object composition.  ZCA adapter is following object adapter
pattern, which use delegation as a mechanism for composition.  GoF's
second principle of object-oriented design goes like this: &quot;Favor
object composition over class inheritance&quot;.  For more details about
this subject please read Design Patterns book.</p>
<p>The major attraction of ZCA adapter are the explicit interface for
components and the component registry.  ZCA adapter components are
registered in component registry and looked up by client objects using
interface and name when required.</p>
<table class="docutils footnote" frame="void" id="feature" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13" name="feature">[11]</a></td><td>Thread discussing renaming of <cite>Feature</cite> to <cite>Adapter</cite>:
<a class="reference" href="http://mail.zope.org/pipermail/zope3-dev/2001-December/000008.html">http://mail.zope.org/pipermail/zope3-dev/2001-December/000008.html</a></td></tr>
</tbody>
</table>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id38" id="utility" name="utility">5&nbsp;&nbsp;&nbsp;Utility</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id39" id="id14" name="id14">5.1&nbsp;&nbsp;&nbsp;Introduction</a></h2>
<p>Now you know the concept of interface, adapter and component registry.
Sometimes it would be useful to register an object which is not
adapting anything.  Database connection, XML parser, object returning
unique Ids etc. are examples of these kinds of objects.  These kind of
components provided by Zope component architecture are called
<tt class="docutils literal"><span class="pre">utility</span></tt> components.</p>
<p>Utilities are just objects that provide an interface and that are
looked up by an interface and a name.  This approach creates a global
registry by which instances can be registered and accessed by
different parts of your application, with no need to pass the
instances around as parameters.</p>
<p>You need not to register all component instances like this.  Only
register components which you want to make replaceable.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id40" id="simple-utility" name="simple-utility">5.2&nbsp;&nbsp;&nbsp;Simple utility</a></h2>
<p>Before implementing the utility, as usual, define its interface.  Here
is a <cite>greeter</cite> interface:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IGreeter(Interface):
...
...     def greet(name):
...         &quot;say hello&quot;
</pre>
<p>Here is a possible implementation of the above interface:</p>
<pre class="literal-block">
&gt;&gt;&gt; class Greeter(object):
...
...     implements(IGreeter)
...
...     def greet(self, name):
...         return &quot;Hello &quot; + name
</pre>
<p>You can register an instance of this class using <tt class="docutils literal"><span class="pre">registerUtility</span></tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; greet = Greeter()
&gt;&gt;&gt; gsm.registerUtility(greet, IGreeter)
</pre>
<p>In this example you registered the utility as providing the <cite>IGreeter</cite>
interface.  You can look the interface up with either <cite>queryUtility</cite>
or <cite>getUtility</cite>:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.component import queryUtility
&gt;&gt;&gt; from zope.component import getUtility

&gt;&gt;&gt; queryUtility(IGreeter).greet('Jack')
'Hello Jack'

&gt;&gt;&gt; getUtility(IGreeter).greet('Jack')
'Hello Jack'
</pre>
<p>As you can see, adapters are normally classes, but utilities are
normally instances of classes.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id41" id="named-utility" name="named-utility">5.3&nbsp;&nbsp;&nbsp;Named utility</a></h2>
<p>When registering a utility component, like adapter, you can use a
name.</p>
<p>For example consider this:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; greet = Greeter()
&gt;&gt;&gt; gsm.registerUtility(greet, IGreeter, 'new')
</pre>
</blockquote>
<p>In this example you registered the utility with a name as providing
the <cite>IGreeter</cite> interface.  You can look the interface up with either
<cite>queryUtility</cite> or <cite>getUtility</cite>:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.component import queryUtility
&gt;&gt;&gt; from zope.component import getUtility

&gt;&gt;&gt; queryUtility(IGreeter, 'new').greet('Jill')
'Hello Jill'

&gt;&gt;&gt; getUtility(IGreeter, 'new').greet('Jill')
'Hello Jill'
</pre>
<p>As you can see here, while querying you have to use the <cite>name</cite> as
second argument.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">Calling <cite>getUtility</cite> function without a name (second argument) is
equivalent to calling with an empty string ('') as the name.
Because, the default value for second (keyword) argument is an empty
string.  Then, component lookup mechanism will try to find the
component with name as empty string (''), and it will fail.  When
component lookup fails it will raise <cite>ComponentLookupError</cite>
exception.  Remember, it will not return some random component
registered with some other name.</p>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id42" id="factory" name="factory">5.4&nbsp;&nbsp;&nbsp;Factory</a></h2>
<p>A <tt class="docutils literal"><span class="pre">Factory</span></tt> is a utility component which provides <tt class="docutils literal"><span class="pre">IFactory</span></tt>
interface.</p>
<p>To create a factory, first define the interface of the object:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IDatabase(Interface):
...
...     def getConnection():
...         &quot;&quot;&quot;Return connection object&quot;&quot;&quot;
</pre>
<p>Here is fake implementation of <cite>IDatabase</cite> interface:</p>
<pre class="literal-block">
&gt;&gt;&gt; class FakeDb(object):
...
...     implements(IDatabase)
...
...     def getConnection(self):
...         return &quot;connection&quot;
</pre>
<p>You can create a factory using <tt class="docutils literal"><span class="pre">zope.component.factory.Factory</span></tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.component.factory import Factory

&gt;&gt;&gt; factory = Factory(FakeDb, 'FakeDb')
</pre>
<p>Now you can register it like this:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; from zope.component.interfaces import IFactory
&gt;&gt;&gt; gsm.registerUtility(factory, IFactory, 'fakedb')
</pre>
<p>To use the factory, you may do it like this:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.component import queryUtility
&gt;&gt;&gt; queryUtility(IFactory, 'fakedb')() #doctest: +ELLIPSIS
&lt;FakeDb object at ...&gt;
</pre>
<p>There is a shortcut to use factory:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.component import createObject
&gt;&gt;&gt; createObject('fakedb') #doctest: +ELLIPSIS
&lt;FakeDb object at ...&gt;
</pre>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id43" id="advanced-adapters" name="advanced-adapters">6&nbsp;&nbsp;&nbsp;Advanced adapters</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id44" id="multi-adapter" name="multi-adapter">6.1&nbsp;&nbsp;&nbsp;Multi adapter</a></h2>
<p>A simple adapter normally adapts only one object, but an adapter can
adapt more than one object.  If an adapter adapts more than one
objects, it is called as multi-adapter.</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements
&gt;&gt;&gt; from zope.component import adapts

&gt;&gt;&gt; class IAdapteeOne(Interface):
...     pass

&gt;&gt;&gt; class IAdapteeTwo(Interface):
...     pass

&gt;&gt;&gt; class IFunctionality(Interface):
...     pass

&gt;&gt;&gt; class MyFunctionality(object):
...     implements(IFunctionality)
...     adapts(IAdapteeOne, IAdapteeTwo)
...
...     def __init__(self, one, two):
...         self.one = one
...         self.two = two

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; gsm.registerAdapter(MyFunctionality)

&gt;&gt;&gt; class One(object):
...     implements(IAdapteeOne)

&gt;&gt;&gt; class Two(object):
...     implements(IAdapteeTwo)

&gt;&gt;&gt; one = One()
&gt;&gt;&gt; two = Two()

&gt;&gt;&gt; from zope.component import getMultiAdapter

&gt;&gt;&gt; getMultiAdapter((one,two), IFunctionality) #doctest: +ELLIPSIS
&lt;MyFunctionality object at ...&gt;

&gt;&gt;&gt; myfunctionality = getMultiAdapter((one,two), IFunctionality)
&gt;&gt;&gt; myfunctionality.one #doctest: +ELLIPSIS
&lt;One object at ...&gt;
&gt;&gt;&gt; myfunctionality.two #doctest: +ELLIPSIS
&lt;Two object at ...&gt;
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id45" id="subscription-adapter" name="subscription-adapter">6.2&nbsp;&nbsp;&nbsp;Subscription adapter</a></h2>
<p>Unlike regular adapters, subscription adapters are used when we want
all of the adapters that adapt an object to a particular adapter.
Subscription adapter is also known as <cite>subscriber</cite> .</p>
<p>Consider a validation problem.  We have objects and we want to assess
whether they meet some sort of standards.  We define a validation
interface:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IValidate(Interface):
...
...     def validate(ob):
...         &quot;&quot;&quot;Determine whether the object is valid
...
...         Return a string describing a validation problem.
...         An empty string is returned to indicate that the
...         object is valid.
...         &quot;&quot;&quot;
</pre>
<p>Perhaps we have documents:</p>
<pre class="literal-block">
&gt;&gt;&gt; class IDocument(Interface):
...
...     summary = Attribute(&quot;Document summary&quot;)
...     body = Attribute(&quot;Document text&quot;)

&gt;&gt;&gt; class Document(object):
...
...     implements(IDocument)
...
...     def __init__(self, summary, body):
...         self.summary, self.body = summary, body
</pre>
<p>Now, we may want to specify various validation rules for
documents. For example, we might require that the summary be a single
line:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from zope.component import adapts
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; class SingleLineSummary:
...
...     adapts(IDocument)
...     implements(IValidate)
...
...     def __init__(self, doc):
...         self.doc = doc
...
...     def validate(self):
...         if '\n' in self.doc.summary:
...             return 'Summary should only have one line'
...         else:
...             return ''
</pre>
</blockquote>
<p>Or we might require the body to be at least 1000 characters in length:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class AdequateLength(object):
...
...     adapts(IDocument)
...     implements(IValidate)
...
...     def __init__(self, doc):
...         self.doc = doc
...
...     def validate(self):
...         if len(self.doc.body) &lt; 1000:
...             return 'too short'
...         else:
...             return ''
</pre>
</blockquote>
<p>We can register these as subscription adapters:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; gsm.registerSubscriptionAdapter(SingleLineSummary)
&gt;&gt;&gt; gsm.registerSubscriptionAdapter(AdequateLength)
</pre>
</blockquote>
<p>We can then use the subscribers to validate objects:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from zope.component import subscribers
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; doc = Document(&quot;A\nDocument&quot;, &quot;blah&quot;)
&gt;&gt;&gt; [adapter.validate()
...  for adapter in subscribers([doc], IValidate)
...  if adapter.validate()]
['Summary should only have one line', 'too short']
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; doc = Document(&quot;A\nDocument&quot;, &quot;blah&quot; * 1000)
&gt;&gt;&gt; [adapter.validate()
...  for adapter in subscribers([doc], IValidate)
...  if adapter.validate()]
['Summary should only have one line']
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; doc = Document(&quot;A Document&quot;, &quot;blah&quot;)
&gt;&gt;&gt; [adapter.validate()
...  for adapter in subscribers([doc], IValidate)
...  if adapter.validate()]
['too short']
</pre>
</blockquote>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id46" id="handler" name="handler">6.3&nbsp;&nbsp;&nbsp;Handler</a></h2>
<p>Handlers are subscription adapter factories that don't produce
anything.  They do all of their work when called.  Handlers are
typically used to handle events.  Handlers are also known as event
subscribers or event subscription adapters.</p>
<p>Event subscribers are different from other subscription adapters in
that the caller of event subscribers doesn't expect to interact with
them in any direct way.  For example, an event publisher doesn't
expect to get any return value.  Because subscribers don't need to
provide an API to their callers, it is more natural to define them
with functions, rather than classes.  For example, in a
document-management system, we might want to record creation times for
documents:</p>
<pre class="literal-block">
&gt;&gt;&gt; import datetime

&gt;&gt;&gt; def documentCreated(event):
...     event.doc.created = datetime.datetime.utcnow()
</pre>
<p>In this example, we have a function that takes an event and performs
some processing.  It doesn't actually return anything.  This is a
special case of a subscription adapter that adapts an event to
nothing.  All of the work is done when the adapter &quot;factory&quot; is
called.  We call subscribers that don't actually create anything
&quot;handlers&quot;.  There are special APIs for registering and calling them.</p>
<p>To register the subscriber above, we define a document-created event:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IDocumentCreated(Interface):
...
...     doc = Attribute(&quot;The document that was created&quot;)

&gt;&gt;&gt; class DocumentCreated(object):
...
...     implements(IDocumentCreated)
...
...     def __init__(self, doc):
...         self.doc = doc
</pre>
<p>We'll also change our handler definition to:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; def documentCreated(event):
...     event.doc.created = datetime.datetime.utcnow()
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; from zope.component import adapter
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; &#64;adapter(IDocumentCreated)
... def documentCreated(event):
...     event.doc.created = datetime.datetime.utcnow()
</pre>
</blockquote>
<p>This marks the handler as an adapter of <cite>IDocumentCreated</cite> events.</p>
<p>Now we'll register the handler:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; gsm.registerHandler(documentCreated)
</pre>
<p>Now, if we can create an event and use the <cite>handle</cite> function to call
handlers registered for the event:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.component import handle

&gt;&gt;&gt; handle(DocumentCreated(doc))
&gt;&gt;&gt; doc.created.__class__.__name__
'datetime'
</pre>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id47" id="zca-usage-in-zope" name="zca-usage-in-zope">7&nbsp;&nbsp;&nbsp;ZCA usage in Zope</a></h1>
<p>Zope Component Architecture is used in both Zope 3 and Zope 2.  This
chapter go through ZCA usage in Zope.</p>
<div class="section">
<h2><a class="toc-backref" href="#id48" id="zcml" name="zcml">7.1&nbsp;&nbsp;&nbsp;ZCML</a></h2>
<p>The Zope Configuration Markup Language (ZCML) is an XML based
configuration system for registration of components.  So, instead of
using Python API for registration, you can use ZCML.  But to use ZCML,
unfortunately, you will be required to install more dependency
packages.</p>
<p>To install these packages:</p>
<pre class="literal-block">
$ easy_install &quot;zope.component [zcml]&quot;
</pre>
<p>To register an adapter:</p>
<pre class="literal-block">
&lt;configure xmlns=&quot;http://namespaces.zope.org/zope&quot;&gt;

&lt;adapter
    factory=&quot;.company.EmployeeSalary&quot;
    provides=&quot;.interfaces.ISalary&quot;
    for=&quot;.interfaces.IEmployee&quot;
    /&gt;
</pre>
<p>The <cite>provides</cite> and <cite>for</cite> attributes are optional, provided you have
declared it in the implementation:</p>
<pre class="literal-block">
&lt;configure xmlns=&quot;http://namespaces.zope.org/zope&quot;&gt;

&lt;adapter
    factory=&quot;.company.EmployeeSalary&quot;
    /&gt;
</pre>
<p>If you want to register the component as named adapter, you can give a
<cite>name</cite> attribute:</p>
<pre class="literal-block">
&lt;configure xmlns=&quot;http://namespaces.zope.org/zope&quot;&gt;

&lt;adapter
    factory=&quot;.company.EmployeeSalary&quot;
    name=&quot;salary&quot;
    /&gt;
</pre>
<p>Utilities are also registered similarly.</p>
<p>To register an utility:</p>
<pre class="literal-block">
&lt;configure xmlns=&quot;http://namespaces.zope.org/zope&quot;&gt;

&lt;utility
    component=&quot;.database.connection&quot;
    provides=&quot;.interfaces.IConnection&quot;
    /&gt;
</pre>
<p>The <cite>provides</cite> attribute is optional, provided you have declared it in
the implementation:</p>
<pre class="literal-block">
&lt;configure xmlns=&quot;http://namespaces.zope.org/zope&quot;&gt;

&lt;utility
    component=&quot;.database.connection&quot;
    /&gt;
</pre>
<p>If you want to register the component as named adapter, you can give a
<cite>name</cite> attribute:</p>
<pre class="literal-block">
&lt;configure xmlns=&quot;http://namespaces.zope.org/zope&quot;&gt;

&lt;utility
    component=&quot;.database.connection&quot;
    name=&quot;Database Connection&quot;
    /&gt;
</pre>
<p>Instead of directly using the component, you can also give a factory:</p>
<pre class="literal-block">
&lt;configure xmlns=&quot;http://namespaces.zope.org/zope&quot;&gt;

&lt;utility
    factory=&quot;.database.Connection&quot;
    /&gt;
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id49" id="overrides" name="overrides">7.2&nbsp;&nbsp;&nbsp;Overrides</a></h2>
<p>When you register components using Python API (<tt class="docutils literal"><span class="pre">register*</span></tt> methods),
the last registered component will replace previously registered
component, if both are registered with same type of arguments.  For
example, consider this example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface

&gt;&gt;&gt; class IA(Interface):
...     pass

&gt;&gt;&gt; class IP(Interface):
...     pass

&gt;&gt;&gt; from zope.interface import implements
&gt;&gt;&gt; from zope.component import adapts

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; class AP(object):
...
...     implements(IP)
...     adapts(IA)
...
...     def __init__(self, context):
...         self.context = context

&gt;&gt;&gt; class AP2(object):
...
...     implements(IP)
...     adapts(IA)
...
...     def __init__(self, context):
...         self.context = context

&gt;&gt;&gt; class A(object):
...
...     implements(IA)

&gt;&gt;&gt; a = A()
&gt;&gt;&gt; ap = AP(a)

&gt;&gt;&gt; gsm.registerAdapter(AP)

&gt;&gt;&gt; getAdapter(a, IP) #doctest: +ELLIPSIS
&lt;AP object at ...&gt;

If you register another adapter, the existing one will be replaced:

&gt;&gt;&gt; gsm.registerAdapter(AP2)

&gt;&gt;&gt; getAdapter(a, IP) #doctest: +ELLIPSIS
&lt;AP2 object at ...&gt;
</pre>
<p>But when registering components using ZCML, the second registration
will raise a conflict error.  This is a hint for you, otherwise there
is a chance for overriding registration by mistake.  This may lead to
hard to track bugs in your system.  So, using ZCML is a win for the
application.</p>
<p>Sometimes you will be required to override existing registration.
ZCML provides <tt class="docutils literal"><span class="pre">includeOverrides</span></tt> directive for this.  Using this,
you can write your overrides in a separate file:</p>
<pre class="literal-block">
&lt;includeOverrides file=&quot;overrides.zcml&quot; /&gt;
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id50" id="namechooser" name="namechooser">7.3&nbsp;&nbsp;&nbsp;NameChooser</a></h2>
<p>Location: <cite>zope.app.container.contained.NameChooser</cite></p>
<p>This is an adapter for choosing a unique name for an object inside a
container.</p>
<p>The registration of adapter is like this:</p>
<pre class="literal-block">
&lt;adapter
    provides=&quot;.interfaces.INameChooser&quot;
    for=&quot;zope.app.container.interfaces.IWriteContainer&quot;
    factory=&quot;.contained.NameChooser&quot;
    /&gt;
</pre>
<p>From the registration, you can see that the adaptee is a
<tt class="docutils literal"><span class="pre">IWriteContainer</span></tt> and the adapter provides <tt class="docutils literal"><span class="pre">INameChooser</span></tt>.</p>
<p>This adapter provides a very convenient functionality for Zope
programmers.  The main implementations of <tt class="docutils literal"><span class="pre">IWriteContainer</span></tt> in
Zope 3 are <tt class="docutils literal"><span class="pre">zope.app.container.BTreeContainer</span></tt> and
<tt class="docutils literal"><span class="pre">zope.app.folder.Folder</span></tt>.  Normally you will be inheriting from
these implementations for creating your own container classes.
Suppose there is no interface called <tt class="docutils literal"><span class="pre">INameChooser</span></tt> and
adapter, then you will be required to implement this functionality
for every implementations separately.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id51" id="locationphysicallylocatable" name="locationphysicallylocatable">7.4&nbsp;&nbsp;&nbsp;LocationPhysicallyLocatable</a></h2>
<p>Location:
<tt class="docutils literal"><span class="pre">zope.location.traversing.LocationPhysicallyLocatable</span></tt></p>
<p>This adapter is frequently used in Zope 3 applications, but
normally it is called through an API in <tt class="docutils literal"><span class="pre">zope.traversing.api</span></tt>.
(Some old code even use <tt class="docutils literal"><span class="pre">zope.app.zapi</span></tt> functions, which is
again one more indirection)</p>
<p>The registration of adapter is like this:</p>
<pre class="literal-block">
&lt;adapter
    factory=&quot;zope.location.traversing.LocationPhysicallyLocatable&quot;
    /&gt;
</pre>
<p>The interface provided and adaptee interface is given in the
implementation.</p>
<p>Here is the beginning of implementation:</p>
<pre class="literal-block">
class LocationPhysicallyLocatable(object):
    &quot;&quot;&quot;Provide location information for location objects
    &quot;&quot;&quot;
    zope.component.adapts(ILocation)
    zope.interface.implements(IPhysicallyLocatable)
    ...
</pre>
<p>Normally, almost all persistent objects in Zope 3 application
will be providing the <tt class="docutils literal"><span class="pre">ILocation</span></tt> interface.  This interface
has only two attribute, <tt class="docutils literal"><span class="pre">__parent__</span></tt> and <tt class="docutils literal"><span class="pre">__name__</span></tt>.  The
<tt class="docutils literal"><span class="pre">__parent__</span></tt> is the parent in the location hierarchy.  And
<tt class="docutils literal"><span class="pre">__name__</span></tt> is the name within the parent.</p>
<p>The <tt class="docutils literal"><span class="pre">IPhysicallyLocatable</span></tt> interface has four methods:
<tt class="docutils literal"><span class="pre">getRoot</span></tt>, <tt class="docutils literal"><span class="pre">getPath</span></tt>, <tt class="docutils literal"><span class="pre">getName</span></tt>, and <tt class="docutils literal"><span class="pre">getNearestSite</span></tt>.</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">getRoot</span></tt> function will return the physical root object.</li>
<li><tt class="docutils literal"><span class="pre">getPath</span></tt> return the physical path to the object as a
string.</li>
<li><tt class="docutils literal"><span class="pre">getName</span></tt> return the last segment of the physical path.</li>
<li><tt class="docutils literal"><span class="pre">getNearestSite</span></tt> return the site the object is contained
in.  If the object is a site, the object itself is returned.</li>
</ul>
</blockquote>
<p>If you learn Zope 3, you can see that these are the important
things which you required very often.  To understand the beauty
of this system, you must see how Zope 2 actually get the physical
root object and how it is implemented.  There is a method called
<tt class="docutils literal"><span class="pre">getPhysicalRoot</span></tt> virtually for all container objects.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id52" id="defaultsized" name="defaultsized">7.5&nbsp;&nbsp;&nbsp;DefaultSized</a></h2>
<p>Location: <tt class="docutils literal"><span class="pre">zope.size.DefaultSized</span></tt></p>
<p>This adapter is just a default implementation of <tt class="docutils literal"><span class="pre">ISized</span></tt> interface.
This adapter is registered for all kind of objects.  If you want to
register this adapter for a particular interface, then you have to
override this registration for your implementation.</p>
<p>The registration of adapter is like this:</p>
<pre class="literal-block">
&lt;adapter
    for=&quot;*&quot;
    factory=&quot;zope.size.DefaultSized&quot;
    provides=&quot;zope.size.interfaces.ISized&quot;
    permission=&quot;zope.View&quot;
    /&gt;
</pre>
<p>As you can see, the adaptee interface is <cite>*</cite>, so it can adapt any kind
of objects.</p>
<p>The <tt class="docutils literal"><span class="pre">ISized</span></tt> is a simple interface with two method contracts:</p>
<pre class="literal-block">
class ISized(Interface):

    def sizeForSorting():
        &quot;&quot;&quot;Returns a tuple (basic_unit, amount)

        Used for sorting among different kinds of sized objects.
        'amount' need only be sortable among things that share the
        same basic unit.&quot;&quot;&quot;

    def sizeForDisplay():
        &quot;&quot;&quot;Returns a string giving the size.
        &quot;&quot;&quot;
</pre>
<p>You can see another <tt class="docutils literal"><span class="pre">ISized</span></tt> adapter registered for <tt class="docutils literal"><span class="pre">IZPTPage</span></tt> in
<tt class="docutils literal"><span class="pre">zope.app.zptpage</span></tt> package.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id53" id="zopeversionutility" name="zopeversionutility">7.6&nbsp;&nbsp;&nbsp;ZopeVersionUtility</a></h2>
<p>Location: <tt class="docutils literal"><span class="pre">zope.app.applicationcontrol.ZopeVersionUtility</span></tt></p>
<p>This utility gives version of the running Zope.</p>
<p>The registration goes like this:</p>
<pre class="literal-block">
&lt;utility
    component=&quot;.zopeversion.ZopeVersionUtility&quot;
    provides=&quot;.interfaces.IZopeVersion&quot; /&gt;
</pre>
<p>The interface provided, <tt class="docutils literal"><span class="pre">IZopeVersion</span></tt>, has only one method named
<tt class="docutils literal"><span class="pre">getZopeVersion</span></tt>.  This method return a string containing the Zope
version (possibly including SVN information).</p>
<p>The default implementation, <tt class="docutils literal"><span class="pre">ZopeVersionUtility</span></tt>, get version info
from a file <tt class="docutils literal"><span class="pre">version.txt</span></tt> in <cite>zope/app</cite> directory.  If Zope is
running from subversion checkout, it will show the latest revision
number.  If none of the above works it will set it to:
<cite>Development/Unknown</cite>.</p>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id54" id="reference" name="reference">8&nbsp;&nbsp;&nbsp;Reference</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id55" id="attribute" name="attribute">8.1&nbsp;&nbsp;&nbsp;Attribute</a></h2>
<p>Using this class, you can define normal attribute in an interface.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.interface</span></tt></li>
<li>Signature: <cite>Attribute(name, doc='')</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface

&gt;&gt;&gt; class IPerson(Interface):
...
...     name = Attribute(&quot;Name of person&quot;)
...     email = Attribute(&quot;Email Address&quot;)
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id56" id="declaration" name="declaration">8.2&nbsp;&nbsp;&nbsp;Declaration</a></h2>
<p>Need not to use directly.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id57" id="interface" name="interface">8.3&nbsp;&nbsp;&nbsp;Interface</a></h2>
<p>Using this class, you can define an interface.  To define an
interface, just inherit from <tt class="docutils literal"><span class="pre">Interface</span></tt> class.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.interface</span></tt></li>
<li>Signature: <cite>Interface(name, doc='')</cite></li>
</ul>
</blockquote>
<p>Example 1:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface

&gt;&gt;&gt; class IPerson(Interface):
...
...     name = Attribute(&quot;Name of person&quot;)
...     email = Attribute(&quot;Email Address&quot;)
</pre>
<p>Example 2:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface

&gt;&gt;&gt; class IHost(Interface):
...
...     def goodmorning(guest):
...         &quot;&quot;&quot;Say good morning to guest&quot;&quot;&quot;
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id58" id="adapts" name="adapts">8.4&nbsp;&nbsp;&nbsp;adapts</a></h2>
<p>This function helps to declare adapter classes.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span></tt></li>
<li>Signature: <cite>adapts(*interfaces)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import implements
&gt;&gt;&gt; from zope.component import adapts

&gt;&gt;&gt; class GuestRegistrarNG(object):
...
...     implements(IRegistrar)
...     adapts(IGuest)
...
...     def __init__(self, guest):
...         self.guest = guest
...
...     def register(self):
...         next_id = get_next_id()
...         guests_db[next_id] = {
...         'name': guest.name,
...         'place': guest.place,
...         'phone': guest.phone
...         }
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id59" id="alsoprovides" name="alsoprovides">8.5&nbsp;&nbsp;&nbsp;alsoProvides</a></h2>
<p>Declare interfaces declared directly for an object.  The arguments
after the object are one or more interfaces.  The interfaces given are
added to the interfaces previously declared for the object.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.interface</span></tt></li>
<li>Signature: <cite>alsoProvides(object, *interfaces)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements
&gt;&gt;&gt; from zope.interface import alsoProvides

&gt;&gt;&gt; class IPerson(Interface):
...
...     name = Attribute(&quot;Name of person&quot;)

&gt;&gt;&gt; class IStudent(Interface):
...
...     college = Attribute(&quot;Name of college&quot;)

&gt;&gt;&gt; class Person(object):
...
...     implements(IRegistrar)
...     name = u&quot;&quot;

&gt;&gt;&gt; jack = Person()
&gt;&gt;&gt; jack.name = &quot;Jack&quot;
&gt;&gt;&gt; jack.college = &quot;New College&quot;
&gt;&gt;&gt; alsoProvides(jack, IStudent)

You can test it like this:

&gt;&gt;&gt; from zope.interface import providedBy
&gt;&gt;&gt; IStudent in providedBy(jack)
True
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id60" id="classimplements" name="classimplements">8.6&nbsp;&nbsp;&nbsp;classImplements</a></h2>
<p>Declare additional interfaces implemented for instances of a class.
The arguments after the class are one or more interfaces.  The
interfaces given are added to any interfaces previously declared.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.interface</span></tt></li>
<li>Signature: <cite>classImplements(cls, *interfaces)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements
&gt;&gt;&gt; from zope.interface import classImplements

&gt;&gt;&gt; class IPerson(Interface):
...
...     name = Attribute(&quot;Name of person&quot;)

&gt;&gt;&gt; class IStudent(Interface):
...
...     college = Attribute(&quot;Name of college&quot;)

&gt;&gt;&gt; class Person(object):
...
...     implements(IRegistrar)
...     name = u&quot;&quot;
...     college = u&quot;&quot;

&gt;&gt;&gt; classImplements(Person, IStudent)
&gt;&gt;&gt; jack = Person()
&gt;&gt;&gt; jack.name = &quot;Jack&quot;
&gt;&gt;&gt; jack.college = &quot;New College&quot;

You can test it like this:

&gt;&gt;&gt; from zope.interface import providedBy
&gt;&gt;&gt; IStudent in providedBy(jack)
True
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id61" id="classimplementsonly" name="classimplementsonly">8.7&nbsp;&nbsp;&nbsp;classImplementsOnly</a></h2>
<p>Declare the only interfaces implemented by instances of a class.  The
arguments after the class are one or more interfaces.  The interfaces
given replace any previous declarations.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.interface</span></tt></li>
<li>Signature: <cite>classImplementsOnly(cls, *interfaces)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements
&gt;&gt;&gt; from zope.interface import classImplementsOnly

&gt;&gt;&gt; class IPerson(Interface):
...
...     name = Attribute(&quot;Name of person&quot;)

&gt;&gt;&gt; class IStudent(Interface):
...
...     college = Attribute(&quot;Name of college&quot;)

&gt;&gt;&gt; class Person(object):
...
...     implements(IPerson)
...     college = u&quot;&quot;

&gt;&gt;&gt; classImplementsOnly(Person, IStudent)
&gt;&gt;&gt; jack = Person()
&gt;&gt;&gt; jack.college = &quot;New College&quot;

You can test it like this:

&gt;&gt;&gt; from zope.interface import providedBy
&gt;&gt;&gt; IPerson in providedBy(jack)
False
&gt;&gt;&gt; IStudent in providedBy(jack)
True
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id62" id="classprovides" name="classprovides">8.8&nbsp;&nbsp;&nbsp;classProvides</a></h2>
<p>Normally if a class implements a particular interface, the instance of
that class will provide the interface implemented by that class.  But
if you want a class to be provided by an interface, you can declare it
using <tt class="docutils literal"><span class="pre">classProvides</span></tt> function.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.interface</span></tt></li>
<li>Signature: <cite>classProvides(*interfaces)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import classProvides

&gt;&gt;&gt; class IPerson(Interface):
...
...     name = Attribute(&quot;Name of person&quot;)

&gt;&gt;&gt; class Person(object):
...
...     classProvides(IPerson)
...     name = u&quot;Jack&quot;

You can test it like this:

&gt;&gt;&gt; from zope.interface import providedBy
&gt;&gt;&gt; IPerson in providedBy(Person)
True
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id63" id="componentlookuperror" name="componentlookuperror">8.9&nbsp;&nbsp;&nbsp;ComponentLookupError</a></h2>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id64" id="createobject" name="createobject">8.10&nbsp;&nbsp;&nbsp;createObject</a></h2>
<p>Create an object using a factory.</p>
<p>Finds the named factory in the current site and calls it with the
given arguments.  If a matching factory cannot be found raises
ComponentLookupError.  Returns the created object.</p>
<p>A context keyword argument can be provided to cause the factory to be
looked up in a location other than the current site.  (Of course, this
means that it is impossible to pass a keyword argument named &quot;context&quot;
to the factory.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span></tt></li>
<li>Signature: <cite>createObject(factory_name, *args, **kwargs)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IDatabase(Interface):
...
...     def getConnection():
...         &quot;&quot;&quot;Return connection object&quot;&quot;&quot;

&gt;&gt;&gt; class FakeDb(object):
...
...     implements(IDatabase)
...
...     def getConnection(self):
...         return &quot;connection&quot;

&gt;&gt;&gt; from zope.component.factory import Factory

&gt;&gt;&gt; factory = Factory(FakeDb, 'FakeDb')

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; from zope.component.interfaces import IFactory
&gt;&gt;&gt; gsm.registerUtility(factory, IFactory, 'fakedb')

&gt;&gt;&gt; from zope.component import createObject
&gt;&gt;&gt; createObject('fakedb') #doctest: +ELLIPSIS
&lt;FakeDb object at ...&gt;
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id65" id="directlyprovidedby" name="directlyprovidedby">8.11&nbsp;&nbsp;&nbsp;directlyProvidedBy</a></h2>
<p>This function will return the interfaces directly provided by the
given object.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.interface</span></tt></li>
<li>Signature: <cite>directlyProvidedBy(object)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface

&gt;&gt;&gt; class IPerson(Interface):
...
...     name = Attribute(&quot;Name of person&quot;)

&gt;&gt;&gt; class IStudent(Interface):
...
...     college = Attribute(&quot;Name of college&quot;)

&gt;&gt;&gt; class ISmartPerson(Interface):
...     pass

&gt;&gt;&gt; class Person(object):
...
...     implements(IPerson)
...     name = u&quot;&quot;

&gt;&gt;&gt; jack = Person()
&gt;&gt;&gt; jack.name = u&quot;Jack&quot;
&gt;&gt;&gt; jack.college = &quot;New College&quot;
&gt;&gt;&gt; alsoProvides(jack, ISmartPerson, IStudent)

&gt;&gt;&gt; from zope.interface import directlyProvidedBy

&gt;&gt;&gt; jack_dp = directlyProvidedBy(jack)
&gt;&gt;&gt; IPerson in jack_dp.interfaces()
False
&gt;&gt;&gt; IStudent in jack_dp.interfaces()
True
&gt;&gt;&gt; ISmartPerson in jack_dp.interfaces()
True
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id66" id="directlyprovides" name="directlyprovides">8.12&nbsp;&nbsp;&nbsp;directlyProvides</a></h2>
<p>Declare interfaces declared directly for an object.  The arguments
after the object are one or more interfaces.  The interfaces given
replace interfaces previously declared for the object.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.interface</span></tt></li>
<li>Signature: <cite>directlyProvides(object, *interfaces)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface

&gt;&gt;&gt; class IPerson(Interface):
...
...     name = Attribute(&quot;Name of person&quot;)

&gt;&gt;&gt; class IStudent(Interface):
...
...     college = Attribute(&quot;Name of college&quot;)

&gt;&gt;&gt; class ISmartPerson(Interface):
...     pass

&gt;&gt;&gt; class Person(object):
...
...     implements(IPerson)
...     name = u&quot;&quot;

&gt;&gt;&gt; jack = Person()
&gt;&gt;&gt; jack.name = u&quot;Jack&quot;
&gt;&gt;&gt; jack.college = &quot;New College&quot;
&gt;&gt;&gt; alsoProvides(jack, ISmartPerson, IStudent)

&gt;&gt;&gt; from zope.interface import directlyProvidedBy

&gt;&gt;&gt; jack_dp = directlyProvidedBy(jack)
&gt;&gt;&gt; ISmartPerson in jack_dp.interfaces()
True
&gt;&gt;&gt; IPerson in jack_dp.interfaces()
False
&gt;&gt;&gt; IStudent in jack_dp.interfaces()
True
&gt;&gt;&gt; from zope.interface import providedBy

&gt;&gt;&gt; ISmartPerson in providedBy(jack)
True

&gt;&gt;&gt; from zope.interface import directlyProvides
&gt;&gt;&gt; directlyProvides(jack, IStudent)

&gt;&gt;&gt; jack_dp = directlyProvidedBy(jack)
&gt;&gt;&gt; ISmartPerson in jack_dp.interfaces()
False
&gt;&gt;&gt; IPerson in jack_dp.interfaces()
False
&gt;&gt;&gt; IStudent in jack_dp.interfaces()
True

&gt;&gt;&gt; ISmartPerson in providedBy(jack)
False
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id67" id="getadapter" name="getadapter">8.13&nbsp;&nbsp;&nbsp;getAdapter</a></h2>
<p>Get a named adapter to an interface for an object.  Returns an adapter
that can adapt object to interface.  If a matching adapter cannot be
found, raises <tt class="docutils literal"><span class="pre">ComponentLookupError</span></tt> .</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.interface</span></tt></li>
<li>Signature: <cite>getAdapter(object, interface=Interface, name=u'', context=None)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface

&gt;&gt;&gt; class IRegistrar(Interface):
...     &quot;&quot;&quot;A registrar will register object's details&quot;&quot;&quot;
...
...     def register():
...         &quot;&quot;&quot;Register object's details&quot;&quot;&quot;
...

&gt;&gt;&gt; from zope.interface import implements
&gt;&gt;&gt; from zope.component import adapts

&gt;&gt;&gt; class GuestRegistrarNG(object):
...
...     implements(IRegistrar)
...     adapts(IGuest)
...
...     def __init__(self, guest):
...         self.guest = guest
...
...     def register(self):
...         next_id = get_next_id()
...         guests_db[next_id] = {
...         'name': guest.name,
...         'place': guest.place,
...         'phone': guest.phone
...         }

&gt;&gt;&gt; class Guest(object):
...
...     implements(IGuest)
...
...     def __init__(self, name, place):
...         self.name = name
...         self.place = place

&gt;&gt;&gt; jack = Guest(&quot;Jack&quot;, &quot;Bangalore&quot;)
&gt;&gt;&gt; jack_registrar = GuestRegistrarNG(jack)

&gt;&gt;&gt; IRegistrar.providedBy(jack_registrar)
True

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()
&gt;&gt;&gt; gsm.registerAdapter(GuestRegistrarNG,
...                     (IGuest,), IRegistrar, 'ng')

&gt;&gt;&gt; getAdapter(jack, IRegistrar, 'ng') #doctest: +ELLIPSIS
&lt;GuestRegistrarNG object at ...&gt;
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id68" id="getadapterincontext" name="getadapterincontext">8.14&nbsp;&nbsp;&nbsp;getAdapterInContext</a></h2>
<p>Instead of this function, use <cite>context</cite> argument of <a class="reference" href="#getadapter">getAdapter</a>
function.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span></tt></li>
<li>Signature: <cite>getAdapterInContext(object, interface, context)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.component.globalregistry import BaseGlobalComponents
&gt;&gt;&gt; from zope.component import IComponentLookup
&gt;&gt;&gt; sm = BaseGlobalComponents()

&gt;&gt;&gt; class Context(object):
...     def __init__(self, sm):
...         self.sm = sm
...     def __conform__(self, interface):
...         if interface.isOrExtends(IComponentLookup):
...             return self.sm

&gt;&gt;&gt; context = Context(sm)

&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface

&gt;&gt;&gt; class IRegistrar(Interface):
...     &quot;&quot;&quot;A registrar will register object's details&quot;&quot;&quot;
...
...     def register():
...         &quot;&quot;&quot;Register object's details&quot;&quot;&quot;
...

&gt;&gt;&gt; from zope.interface import implements
&gt;&gt;&gt; from zope.component import adapts

&gt;&gt;&gt; class GuestRegistrarNG(object):
...
...     implements(IRegistrar)
...     adapts(IGuest)
...
...     def __init__(self, guest):
...         self.guest = guest
...
...     def register(self):
...         next_id = get_next_id()
...         guests_db[next_id] = {
...         'name': guest.name,
...         'place': guest.place,
...         'phone': guest.phone
...         }

&gt;&gt;&gt; class Guest(object):
...
...     implements(IGuest)
...
...     def __init__(self, name, place):
...         self.name = name
...         self.place = place

&gt;&gt;&gt; jack = Guest(&quot;Jack&quot;, &quot;Bangalore&quot;)
&gt;&gt;&gt; jack_registrar = GuestRegistrarNG(jack)

&gt;&gt;&gt; IRegistrar.providedBy(jack_registrar)
True

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()
&gt;&gt;&gt; sm.registerAdapter(GuestRegistrarNG,
...                     (IGuest,), IRegistrar)

&gt;&gt;&gt; from zope.component import getAdapterInContext
&gt;&gt;&gt; from zope.component import queryAdapterInContext

&gt;&gt;&gt; getAdapterInContext(jack, IRegistrar, sm) #doctest: +ELLIPSIS
&lt;GuestRegistrarNG object at ...&gt;
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id69" id="getadapters" name="getadapters">8.15&nbsp;&nbsp;&nbsp;getAdapters</a></h2>
<p>Look for all matching adapters to a provided interface for objects.
Return a list of adapters that match. If an adapter is named, only the
most specific adapter of a given name is returned.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span></tt></li>
<li>Signature: <cite>getAdapters(objects, provided, context=None)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import implements
&gt;&gt;&gt; from zope.component import adapts

&gt;&gt;&gt; class GuestRegistrarNG(object):
...
...     implements(IRegistrar)
...     adapts(IGuest)
...
...     def __init__(self, guest):
...         self.guest = guest
...
...     def register(self):
...         next_id = get_next_id()
...         guests_db[next_id] = {
...         'name': guest.name,
...         'place': guest.place,
...         'phone': guest.phone
...         }

&gt;&gt;&gt; jack = Guest(&quot;Jack&quot;, &quot;Bangalore&quot;)
&gt;&gt;&gt; jack_registrar = GuestRegistrarNG(jack)

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; gsm.registerAdapter(GuestRegistrarNG, name='ng')

&gt;&gt;&gt; from zope.component import getAdapters
&gt;&gt;&gt; list(getAdapters((jack,), IRegistrar)) #doctest: +ELLIPSIS
[(u'ng', &lt;GuestRegistrarNG object at ...&gt;)]
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id70" id="getallutilitiesregisteredfor" name="getallutilitiesregisteredfor">8.16&nbsp;&nbsp;&nbsp;getAllUtilitiesRegisteredFor</a></h2>
<p>Return all registered utilities for an interface.  This includes
overridden utilities.  The returned value is an iterable of utility
instances.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span></tt></li>
<li>Signature: <cite>getAllUtilitiesRegisteredFor(interface)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IGreeter(Interface):
...     def greet(name):
...         &quot;say hello&quot;

&gt;&gt;&gt; class Greeter(object):
...
...     implements(IGreeter)
...
...     def greet(self, name):
...         print &quot;Hello&quot;, name

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; greet = Greeter()
&gt;&gt;&gt; gsm.registerUtility(greet, IGreeter)

&gt;&gt;&gt; from zope.component import getAllUtilitiesRegisteredFor

&gt;&gt;&gt; getAllUtilitiesRegisteredFor(IGreeter) #doctest: +ELLIPSIS
[&lt;Greeter object at ...&gt;]
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id71" id="getfactoriesfor" name="getfactoriesfor">8.17&nbsp;&nbsp;&nbsp;getFactoriesFor</a></h2>
<p>Return a tuple (name, factory) of registered factories that create
objects which implement the given interface.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span></tt></li>
<li>Signature: <cite>getFactoriesFor(interface, context=None)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IDatabase(Interface):
...
...     def getConnection():
...         &quot;&quot;&quot;Return connection object&quot;&quot;&quot;

&gt;&gt;&gt; class FakeDb(object):
...
...     implements(IDatabase)
...
...     def getConnection(self):
...         return &quot;connection&quot;

&gt;&gt;&gt; from zope.component.factory import Factory

&gt;&gt;&gt; factory = Factory(FakeDb, 'FakeDb')

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; from zope.component.interfaces import IFactory
&gt;&gt;&gt; gsm.registerUtility(factory, IFactory, 'fakedb')

&gt;&gt;&gt; from zope.component import getFactoriesFor

&gt;&gt;&gt; list(getFactoriesFor(IDatabase))
[(u'fakedb', &lt;Factory for &lt;class 'FakeDb'&gt;&gt;)]
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id72" id="getfactoryinterfaces" name="getfactoryinterfaces">8.18&nbsp;&nbsp;&nbsp;getFactoryInterfaces</a></h2>
<p>Get interfaces implemented by a factory.  Finds the factory of the
given name that is nearest to the context, and returns the interface
or interface tuple that object instances created by the named factory
will implement.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span></tt></li>
<li>Signature: <cite>getFactoryInterfaces(name, context=None)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IDatabase(Interface):
...
...     def getConnection():
...         &quot;&quot;&quot;Return connection object&quot;&quot;&quot;

&gt;&gt;&gt; class FakeDb(object):
...
...     implements(IDatabase)
...
...     def getConnection(self):
...         return &quot;connection&quot;

&gt;&gt;&gt; from zope.component.factory import Factory

&gt;&gt;&gt; factory = Factory(FakeDb, 'FakeDb')

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; from zope.component.interfaces import IFactory
&gt;&gt;&gt; gsm.registerUtility(factory, IFactory, 'fakedb')

&gt;&gt;&gt; from zope.component import getFactoryInterfaces

&gt;&gt;&gt; getFactoryInterfaces('fakedb')
&lt;implementedBy __builtin__.FakeDb&gt;
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id73" id="getglobalsitemanager" name="getglobalsitemanager">8.19&nbsp;&nbsp;&nbsp;getGlobalSiteManager</a></h2>
<p>Return the global site manager.  This function should never fail and
always return an object that provides <cite>IGlobalSiteManager</cite></p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span></tt></li>
<li>Signature: <cite>getGlobalSiteManager()</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; from zope.component import globalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()
&gt;&gt;&gt; gsm is globalSiteManager
True
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id74" id="getmultiadapter" name="getmultiadapter">8.20&nbsp;&nbsp;&nbsp;getMultiAdapter</a></h2>
<p>Look for a multi-adapter to an interface for an objects.  Returns a
multi-adapter that can adapt objects to interface.  If a matching
adapter cannot be found, raises ComponentLookupError.  The name
consisting of an empty string is reserved for unnamed adapters. The
unnamed adapter methods will often call the named adapter methods with
an empty string for a name.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span></tt></li>
<li>Signature: <cite>getMultiAdapter(objects, interface=Interface, name='',
context=None)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements
&gt;&gt;&gt; from zope.component import adapts

&gt;&gt;&gt; class IAdapteeOne(Interface):
...     pass

&gt;&gt;&gt; class IAdapteeTwo(Interface):
...     pass

&gt;&gt;&gt; class IFunctionality(Interface):
...     pass

&gt;&gt;&gt; class MyFunctionality(object):
...     implements(IFunctionality)
...     adapts(IAdapteeOne, IAdapteeTwo)
...
...     def __init__(self, one, two):
...         self.one = one
...         self.two = two

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; gsm.registerAdapter(MyFunctionality)

&gt;&gt;&gt; class One(object):
...     implements(IAdapteeOne)

&gt;&gt;&gt; class Two(object):
...     implements(IAdapteeTwo)

&gt;&gt;&gt; one = One()
&gt;&gt;&gt; two = Two()

&gt;&gt;&gt; from zope.component import getMultiAdapter

&gt;&gt;&gt; getMultiAdapter((one,two), IFunctionality) #doctest: +ELLIPSIS
&lt;MyFunctionality object at ...&gt;

&gt;&gt;&gt; myfunctionality = getMultiAdapter((one,two), IFunctionality)
&gt;&gt;&gt; myfunctionality.one #doctest: +ELLIPSIS
&lt;One object at ...&gt;
&gt;&gt;&gt; myfunctionality.two #doctest: +ELLIPSIS
&lt;Two object at ...&gt;
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id75" id="getsitemanager" name="getsitemanager">8.21&nbsp;&nbsp;&nbsp;getSiteManager</a></h2>
<p>Get the nearest site manager in the given context.  If <cite>context</cite> is
<cite>None</cite>, return the global site manager.  If the <cite>context</cite> is not
<cite>None</cite>, it is expected that an adapter from the <cite>context</cite> to
<cite>IComponentLookup</cite> can be found.  If no adapter is found, a
<cite>ComponentLookupError</cite> is raised.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span></tt></li>
<li>Signature: <cite>getSiteManager(context=None)</cite></li>
</ul>
</blockquote>
<p>Example 1:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.component.globalregistry import BaseGlobalComponents
&gt;&gt;&gt; from zope.component import IComponentLookup
&gt;&gt;&gt; sm = BaseGlobalComponents()

&gt;&gt;&gt; class Context(object):
...     def __init__(self, sm):
...         self.sm = sm
...     def __conform__(self, interface):
...         if interface.isOrExtends(IComponentLookup):
...             return self.sm

&gt;&gt;&gt; context = Context(sm)

&gt;&gt;&gt; from zope.component import getSiteManager

&gt;&gt;&gt; lsm = getSiteManager(context)
&gt;&gt;&gt; lsm is sm
True
</pre>
<p>Example 2:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; sm = getSiteManager()
&gt;&gt;&gt; gsm is sm
True
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id76" id="getutilitiesfor" name="getutilitiesfor">8.22&nbsp;&nbsp;&nbsp;getUtilitiesFor</a></h2>
<p>Look up the registered utilities that provide an interface.  Returns
an iterable of name-utility pairs.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span></tt></li>
<li>Signature: <cite>getUtilitiesFor(interface)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IGreeter(Interface):
...     def greet(name):
...         &quot;say hello&quot;

&gt;&gt;&gt; class Greeter(object):
...
...     implements(IGreeter)
...
...     def greet(self, name):
...         print &quot;Hello&quot;, name

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; greet = Greeter()
&gt;&gt;&gt; gsm.registerUtility(greet, IGreeter)

&gt;&gt;&gt; from zope.component import getUtilitiesFor

&gt;&gt;&gt; list(getUtilitiesFor(IGreeter)) #doctest: +ELLIPSIS
[(u'', &lt;Greeter object at ...&gt;)]
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id77" id="getutility" name="getutility">8.23&nbsp;&nbsp;&nbsp;getUtility</a></h2>
<p>Get the utility that provides interface.  Returns the nearest utility
to the context that implements the specified interface.  If one is not
found, raises ComponentLookupError.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span></tt></li>
<li>Signature: <cite>getUtility(interface, name='', context=None)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IGreeter(Interface):
...     def greet(name):
...         &quot;say hello&quot;

&gt;&gt;&gt; class Greeter(object):
...
...     implements(IGreeter)
...
...     def greet(self, name):
...         return &quot;Hello &quot; + name

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; greet = Greeter()
&gt;&gt;&gt; gsm.registerUtility(greet, IGreeter)

&gt;&gt;&gt; from zope.component import getUtility

&gt;&gt;&gt; getUtility(IGreeter).greet('Jack')
'Hello Jack'
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id78" id="handle" name="handle">8.24&nbsp;&nbsp;&nbsp;handle</a></h2>
<p>Call all of the handlers for the given objects.  Handlers are
subscription adapter factories that don't produce anything.  They do
all of their work when called.  Handlers are typically used to handle
events.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span></tt></li>
<li>Signature: <cite>handle(*objects)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; import datetime

&gt;&gt;&gt; def documentCreated(event):
...     event.doc.created = datetime.datetime.utcnow()

&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IDocumentCreated(Interface):
...     doc = Attribute(&quot;The document that was created&quot;)

&gt;&gt;&gt; class DocumentCreated(object):
...     implements(IDocumentCreated)
...
...     def __init__(self, doc):
...         self.doc = doc


&gt;&gt;&gt; def documentCreated(event):
...     event.doc.created = datetime.datetime.utcnow()

&gt;&gt;&gt; from zope.component import adapter

&gt;&gt;&gt; &#64;adapter(IDocumentCreated)
... def documentCreated(event):
...     event.doc.created = datetime.datetime.utcnow()


&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; gsm.registerHandler(documentCreated)

&gt;&gt;&gt; from zope.component import handle

&gt;&gt;&gt; handle(DocumentCreated(doc))
&gt;&gt;&gt; doc.created.__class__.__name__
'datetime'
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id79" id="implementedby" name="implementedby">8.25&nbsp;&nbsp;&nbsp;implementedBy</a></h2>
<p>Return the interfaces implemented for a class' instances.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.interface</span></tt></li>
<li>Signature: <cite>implementedBy(class_)</cite></li>
</ul>
</blockquote>
<p>Example 1:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IGreeter(Interface):
...     def greet(name):
...         &quot;say hello&quot;

&gt;&gt;&gt; class Greeter(object):
...
...     implements(IGreeter)
...
...     def greet(self, name):
...         print &quot;Hello&quot;, name

&gt;&gt;&gt; from zope.interface import implementedBy
&gt;&gt;&gt; implementedBy(Greeter)
&lt;implementedBy __builtin__.Greeter&gt;
</pre>
<p>Example 2:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IPerson(Interface):
...     name = Attribute(&quot;Name of person&quot;)

&gt;&gt;&gt; class ISpecial(Interface):
...     pass

&gt;&gt;&gt; class Person(object):
...     implements(IPerson)
...     name = u&quot;&quot;

&gt;&gt;&gt; from zope.interface import classImplements
&gt;&gt;&gt; classImplements(Person, ISpecial)

&gt;&gt;&gt; from zope.interface import implementedBy

To get a list of all interfaces implemented by that class::

&gt;&gt;&gt; [x.__name__ for x in implementedBy(Person)]
['IPerson', 'ISpecial']
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id80" id="implementer" name="implementer">8.26&nbsp;&nbsp;&nbsp;implementer</a></h2>
<p>Create a decorator for declaring interfaces implemented by a factory.
A callable is returned that makes an implements declaration on objects
passed to it.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.interface</span></tt></li>
<li>Signature: <cite>implementer(*interfaces)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import implementer
&gt;&gt;&gt; class IFoo(Interface):
...     pass
&gt;&gt;&gt; class Foo(object):
...     implements(IFoo)

&gt;&gt;&gt; &#64;implementer(IFoo)
... def foocreator():
...     foo = Foo()
...     return foo
&gt;&gt;&gt; list(implementedBy(foocreator))
[&lt;InterfaceClass __builtin__.IFoo&gt;]
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id81" id="implements" name="implements">8.27&nbsp;&nbsp;&nbsp;implements</a></h2>
<p>Declare interfaces implemented by instances of a class This function
is called in a class definition.  The arguments are one or more
interfaces.  The interfaces given are added to any interfaces
previously declared.  Previous declarations include declarations for
base classes unless implementsOnly was used.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.interface</span></tt></li>
<li>Signature: <cite>implements(*interfaces)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IPerson(Interface):
...
...     name = Attribute(&quot;Name of person&quot;)

&gt;&gt;&gt; class Person(object):
...
...     implements(IPerson)
...     name = u&quot;&quot;

&gt;&gt;&gt; jack = Person()
&gt;&gt;&gt; jack.name = &quot;Jack&quot;

You can test it like this:

&gt;&gt;&gt; from zope.interface import providedBy
&gt;&gt;&gt; IPerson in providedBy(jack)
True
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id82" id="implementsonly" name="implementsonly">8.28&nbsp;&nbsp;&nbsp;implementsOnly</a></h2>
<p>Declare the only interfaces implemented by instances of a class.  This
function is called in a class definition.  The arguments are one or
more interfaces.  Previous declarations including declarations for
base classes are overridden.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.interface</span></tt></li>
<li>Signature: <cite>implementsOnly(*interfaces)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements
&gt;&gt;&gt; from zope.interface import implementsOnly

&gt;&gt;&gt; class IPerson(Interface):
...
...     name = Attribute(&quot;Name of person&quot;)

&gt;&gt;&gt; class IStudent(Interface):
...
...     college = Attribute(&quot;Name of college&quot;)

&gt;&gt;&gt; class Person(object):
...
...     implements(IPerson)
...     name = u&quot;&quot;

&gt;&gt;&gt; class NewPerson(Person):
...     implementsOnly(IStudent)
...     college = u&quot;&quot;

&gt;&gt;&gt; jack = NewPerson()
&gt;&gt;&gt; jack.college = &quot;New College&quot;

You can test it like this:

&gt;&gt;&gt; from zope.interface import providedBy
&gt;&gt;&gt; IPerson in providedBy(jack)
False
&gt;&gt;&gt; IStudent in providedBy(jack)
True
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id83" id="moduleprovides" name="moduleprovides">8.29&nbsp;&nbsp;&nbsp;moduleProvides</a></h2>
<p>Declare interfaces provided by a module.  This function is used in a
module definition.  The arguments are one or more interfaces.  The
given interfaces are used to create the module's direct-object
interface specification.  An error will be raised if the module
already has an interface specification.  In other words, it is an
error to call this function more than once in a module definition.</p>
<p>This function is provided for convenience. It provides a more
convenient way to call directlyProvides for a module.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.interface</span></tt></li>
<li>Signature: <cite>moduleProvides(*interfaces)</cite></li>
</ul>
</blockquote>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id84" id="nolongerprovides" name="nolongerprovides">8.30&nbsp;&nbsp;&nbsp;noLongerProvides</a></h2>
<p>Remove an interface from the list of an object's directly provided
interfaces.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.interface</span></tt></li>
<li>Signature: <cite>noLongerProvides(object, interface)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements
&gt;&gt;&gt; from zope.interface import classImplements

&gt;&gt;&gt; class IPerson(Interface):
...
...     name = Attribute(&quot;Name of person&quot;)

&gt;&gt;&gt; class IStudent(Interface):
...
...     college = Attribute(&quot;Name of college&quot;)

&gt;&gt;&gt; class Person(object):
...
...     implements(IPerson)
...     name = u&quot;&quot;

&gt;&gt;&gt; jack = Person()
&gt;&gt;&gt; jack.name = &quot;Jack&quot;
&gt;&gt;&gt; jack.college = &quot;New College&quot;
&gt;&gt;&gt; directlyProvides(jack, IStudent)

You can test it like this:

&gt;&gt;&gt; from zope.interface import providedBy
&gt;&gt;&gt; IPerson in providedBy(jack)
True
&gt;&gt;&gt; IStudent in providedBy(jack)
True
&gt;&gt;&gt; from zope.interface import noLongerProvides
&gt;&gt;&gt; noLongerProvides(jack, IStudent)
&gt;&gt;&gt; IPerson in providedBy(jack)
True
&gt;&gt;&gt; IStudent in providedBy(jack)
False
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id85" id="provideadapter" name="provideadapter">8.31&nbsp;&nbsp;&nbsp;provideAdapter</a></h2>
<p>It is recommend to use <a class="reference" href="#registeradapter">registerAdapter</a> .</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id86" id="providehandler" name="providehandler">8.32&nbsp;&nbsp;&nbsp;provideHandler</a></h2>
<p>It is recommend to use <a class="reference" href="#registerhandler">registerHandler</a> .</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id87" id="providesubscriptionadapter" name="providesubscriptionadapter">8.33&nbsp;&nbsp;&nbsp;provideSubscriptionAdapter</a></h2>
<p>It is recommend to use <a class="reference" href="#registersubscriptionadapter">registerSubscriptionAdapter</a> .</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id88" id="provideutility" name="provideutility">8.34&nbsp;&nbsp;&nbsp;provideUtility</a></h2>
<p>It is recommend to use <a class="reference" href="#registerutility">registerUtility</a> .</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id89" id="providedby" name="providedby">8.35&nbsp;&nbsp;&nbsp;providedBy</a></h2>
<p>Test whether the interface is implemented by the object. Return true
if the object asserts that it implements the interface, including
asserting that it implements an extended interface.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.interface</span></tt></li>
<li>Signature: <cite>providedBy(object)</cite></li>
</ul>
</blockquote>
<p>Example 1:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IPerson(Interface):
...
...     name = Attribute(&quot;Name of person&quot;)

&gt;&gt;&gt; class Person(object):
...
...     implements(IPerson)
...     name = u&quot;&quot;

&gt;&gt;&gt; jack = Person()
&gt;&gt;&gt; jack.name = &quot;Jack&quot;

You can test it like this:

&gt;&gt;&gt; from zope.interface import providedBy
&gt;&gt;&gt; IPerson in providedBy(jack)
True
</pre>
<p>Example 2:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IPerson(Interface):
...     name = Attribute(&quot;Name of person&quot;)

&gt;&gt;&gt; class ISpecial(Interface):
...     pass

&gt;&gt;&gt; class Person(object):
...     implements(IPerson)
...     name = u&quot;&quot;

&gt;&gt;&gt; from zope.interface import classImplements
&gt;&gt;&gt; classImplements(Person, ISpecial)
&gt;&gt;&gt; from zope.interface import providedBy
&gt;&gt;&gt; jack = Person()
&gt;&gt;&gt; jack.name = &quot;Jack&quot;

To get a list of all interfaces provided by that object::

&gt;&gt;&gt; [x.__name__ for x in providedBy(jack)]
['IPerson', 'ISpecial']
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id90" id="queryadapter" name="queryadapter">8.36&nbsp;&nbsp;&nbsp;queryAdapter</a></h2>
<p>Look for a named adapter to an interface for an object.  Returns an
adapter that can adapt object to interface.  If a matching adapter
cannot be found, returns the default.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span></tt></li>
<li>Signature: <cite>queryAdapter(object, interface=Interface, name=u'',
default=None, context=None)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface

&gt;&gt;&gt; class IRegistrar(Interface):
...     &quot;&quot;&quot;A registrar will register object's details&quot;&quot;&quot;
...
...     def register():
...         &quot;&quot;&quot;Register object's details&quot;&quot;&quot;
...

&gt;&gt;&gt; from zope.interface import implements
&gt;&gt;&gt; from zope.component import adapts

&gt;&gt;&gt; class GuestRegistrarNG(object):
...
...     implements(IRegistrar)
...     adapts(IGuest)
...
...     def __init__(self, guest):
...         self.guest = guest
...
...     def register(self):
...         next_id = get_next_id()
...         guests_db[next_id] = {
...         'name': guest.name,
...         'place': guest.place,
...         'phone': guest.phone
...         }

&gt;&gt;&gt; class Guest(object):
...
...     implements(IGuest)
...
...     def __init__(self, name, place):
...         self.name = name
...         self.place = place

&gt;&gt;&gt; jack = Guest(&quot;Jack&quot;, &quot;Bangalore&quot;)
&gt;&gt;&gt; jack_registrar = GuestRegistrarNG(jack)

&gt;&gt;&gt; IRegistrar.providedBy(jack_registrar)
True

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()
&gt;&gt;&gt; gsm.registerAdapter(GuestRegistrarNG,
...                     (IGuest,), IRegistrar, 'ng')

&gt;&gt;&gt; queryAdapter(jack, IRegistrar, 'ng') #doctest: +ELLIPSIS
&lt;GuestRegistrarNG object at ...&gt;
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id91" id="queryadapterincontext" name="queryadapterincontext">8.37&nbsp;&nbsp;&nbsp;queryAdapterInContext</a></h2>
<p>Instead of this function, use <cite>context</cite> argument of <a class="reference" href="#queryadapter">queryAdapter</a>
function.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span></tt></li>
<li>Signature: <cite>queryAdapterInContext(object, interface, context,
default=None)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.component.globalregistry import BaseGlobalComponents
&gt;&gt;&gt; from zope.component import IComponentLookup
&gt;&gt;&gt; sm = BaseGlobalComponents()

&gt;&gt;&gt; class Context(object):
...     def __init__(self, sm):
...         self.sm = sm
...     def __conform__(self, interface):
...         if interface.isOrExtends(IComponentLookup):
...             return self.sm

&gt;&gt;&gt; context = Context(sm)

&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface

&gt;&gt;&gt; class IRegistrar(Interface):
...     &quot;&quot;&quot;A registrar will register object's details&quot;&quot;&quot;
...
...     def register():
...         &quot;&quot;&quot;Register object's details&quot;&quot;&quot;
...

&gt;&gt;&gt; from zope.interface import implements
&gt;&gt;&gt; from zope.component import adapts

&gt;&gt;&gt; class GuestRegistrarNG(object):
...
...     implements(IRegistrar)
...     adapts(IGuest)
...
...     def __init__(self, guest):
...         self.guest = guest
...
...     def register(self):
...         next_id = get_next_id()
...         guests_db[next_id] = {
...         'name': guest.name,
...         'place': guest.place,
...         'phone': guest.phone
...         }

&gt;&gt;&gt; class Guest(object):
...
...     implements(IGuest)
...
...     def __init__(self, name, place):
...         self.name = name
...         self.place = place

&gt;&gt;&gt; jack = Guest(&quot;Jack&quot;, &quot;Bangalore&quot;)
&gt;&gt;&gt; jack_registrar = GuestRegistrarNG(jack)

&gt;&gt;&gt; IRegistrar.providedBy(jack_registrar)
True

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()
&gt;&gt;&gt; sm.registerAdapter(GuestRegistrarNG,
...                     (IGuest,), IRegistrar)

&gt;&gt;&gt; from zope.component import getAdapterInContext
&gt;&gt;&gt; from zope.component import queryAdapterInContext

&gt;&gt;&gt; queryAdapterInContext(jack, IRegistrar, sm) #doctest: +ELLIPSIS
&lt;GuestRegistrarNG object at ...&gt;
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id92" id="querymultiadapter" name="querymultiadapter">8.38&nbsp;&nbsp;&nbsp;queryMultiAdapter</a></h2>
<p>Look for a multi-adapter to an interface for objects.  Returns a
multi-adapter that can adapt objects to interface.  If a matching
adapter cannot be found, returns the default.  The name consisting of
an empty string is reserved for unnamed adapters.  The unnamed adapter
methods will often call the named adapter methods with an empty string
for a name.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span></tt></li>
<li>Signature: <cite>queryMultiAdapter(objects, interface=Interface,
name=u'', default=None, context=None)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements
&gt;&gt;&gt; from zope.component import adapts

&gt;&gt;&gt; class IAdapteeOne(Interface):
...     pass

&gt;&gt;&gt; class IAdapteeTwo(Interface):
...     pass

&gt;&gt;&gt; class IFunctionality(Interface):
...     pass

&gt;&gt;&gt; class MyFunctionality(object):
...     implements(IFunctionality)
...     adapts(IAdapteeOne, IAdapteeTwo)
...
...     def __init__(self, one, two):
...         self.one = one
...         self.two = two

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; gsm.registerAdapter(MyFunctionality)

&gt;&gt;&gt; class One(object):
...     implements(IAdapteeOne)

&gt;&gt;&gt; class Two(object):
...     implements(IAdapteeTwo)

&gt;&gt;&gt; one = One()
&gt;&gt;&gt; two = Two()

&gt;&gt;&gt; from zope.component import queryMultiAdapter

&gt;&gt;&gt; getMultiAdapter((one,two), IFunctionality) #doctest: +ELLIPSIS
&lt;MyFunctionality object at ...&gt;

&gt;&gt;&gt; myfunctionality = queryMultiAdapter((one,two), IFunctionality)
&gt;&gt;&gt; myfunctionality.one #doctest: +ELLIPSIS
&lt;One object at ...&gt;
&gt;&gt;&gt; myfunctionality.two #doctest: +ELLIPSIS
&lt;Two object at ...&gt;
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id93" id="queryutility" name="queryutility">8.39&nbsp;&nbsp;&nbsp;queryUtility</a></h2>
<p>Look up a utility that provides an interface.  If one is not found,
returns default.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span></tt></li>
<li>Signature: <cite>queryUtility(interface, name='', default=None)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IGreeter(Interface):
...     def greet(name):
...         &quot;say hello&quot;

&gt;&gt;&gt; class Greeter(object):
...
...     implements(IGreeter)
...
...     def greet(self, name):
...         return &quot;Hello &quot; + name

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; greet = Greeter()
&gt;&gt;&gt; gsm.registerUtility(greet, IGreeter)

&gt;&gt;&gt; from zope.component import queryUtility

&gt;&gt;&gt; queryUtility(IGreeter).greet('Jack')
'Hello Jack'
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id94" id="registeradapter" name="registeradapter">8.40&nbsp;&nbsp;&nbsp;registerAdapter</a></h2>
<p>Register an adapter factory.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span> <span class="pre">-</span> <span class="pre">IComponentRegistry</span></tt></li>
<li>Signature: <cite>registerAdapter(factory, required=None, provided=None,
name=u'', info=u'')</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface

&gt;&gt;&gt; class IRegistrar(Interface):
...     &quot;&quot;&quot;A registrar will register object's details&quot;&quot;&quot;
...
...     def register():
...         &quot;&quot;&quot;Register object's details&quot;&quot;&quot;
...

&gt;&gt;&gt; from zope.interface import implements
&gt;&gt;&gt; from zope.component import adapts

&gt;&gt;&gt; class GuestRegistrarNG(object):
...
...     implements(IRegistrar)
...     adapts(IGuest)
...
...     def __init__(self, guest):
...         self.guest = guest
...
...     def register(self):
...         next_id = get_next_id()
...         guests_db[next_id] = {
...         'name': guest.name,
...         'place': guest.place,
...         'phone': guest.phone
...         }

&gt;&gt;&gt; class Guest(object):
...
...     implements(IGuest)
...
...     def __init__(self, name, place):
...         self.name = name
...         self.place = place

&gt;&gt;&gt; jack = Guest(&quot;Jack&quot;, &quot;Bangalore&quot;)
&gt;&gt;&gt; jack_registrar = GuestRegistrarNG(jack)

&gt;&gt;&gt; IRegistrar.providedBy(jack_registrar)
True

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()
&gt;&gt;&gt; gsm.registerAdapter(GuestRegistrarNG,
...                     (IGuest,), IRegistrar, 'ng')

You can test it like this:

&gt;&gt;&gt; queryAdapter(jack, IRegistrar, 'ng') #doctest: +ELLIPSIS
&lt;GuestRegistrarNG object at ...&gt;
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id95" id="registeredadapters" name="registeredadapters">8.41&nbsp;&nbsp;&nbsp;registeredAdapters</a></h2>
<p>Return an iterable of <cite>IAdapterRegistrations</cite>.  These registrations
describe the current adapter registrations in the object.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span> <span class="pre">-</span> <span class="pre">IComponentRegistry</span></tt></li>
<li>Signature: <cite>registeredAdapters()</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface

&gt;&gt;&gt; class IRegistrar(Interface):
...     &quot;&quot;&quot;A registrar will register object's details&quot;&quot;&quot;
...
...     def register():
...         &quot;&quot;&quot;Register object's details&quot;&quot;&quot;
...

&gt;&gt;&gt; from zope.interface import implements
&gt;&gt;&gt; from zope.component import adapts

&gt;&gt;&gt; class GuestRegistrarNG(object):
...
...     implements(IRegistrar)
...     adapts(IGuest)
...
...     def __init__(self, guest):
...         self.guest = guest
...
...     def register(self):
...         next_id = get_next_id()
...         guests_db[next_id] = {
...         'name': guest.name,
...         'place': guest.place,
...         'phone': guest.phone
...         }

&gt;&gt;&gt; class Guest(object):
...
...     implements(IGuest)
...
...     def __init__(self, name, place):
...         self.name = name
...         self.place = place

&gt;&gt;&gt; jack = Guest(&quot;Jack&quot;, &quot;Bangalore&quot;)
&gt;&gt;&gt; jack_registrar = GuestRegistrarNG(jack)

&gt;&gt;&gt; IRegistrar.providedBy(jack_registrar)
True

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()
&gt;&gt;&gt; gsm.registerAdapter(GuestRegistrarNG,
...                     (IGuest,), IRegistrar, 'ng2')


&gt;&gt;&gt; reg_adapter = list(gsm.registeredAdapters())
&gt;&gt;&gt; 'ng2' in [x.name for x in reg_adapter]
True
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id96" id="registeredhandlers" name="registeredhandlers">8.42&nbsp;&nbsp;&nbsp;registeredHandlers</a></h2>
<p>Return an iterable of <cite>IHandlerRegistrations</cite>.  These registrations
describe the current handler registrations in the object.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span> <span class="pre">-</span> <span class="pre">IComponentRegistry</span></tt></li>
<li>Signature: <cite>registeredHandlers()</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; import datetime

&gt;&gt;&gt; def documentCreated(event):
...     event.doc.created = datetime.datetime.utcnow()

&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IDocumentCreated(Interface):
...     doc = Attribute(&quot;The document that was created&quot;)

&gt;&gt;&gt; class DocumentCreated(object):
...     implements(IDocumentCreated)
...
...     def __init__(self, doc):
...         self.doc = doc


&gt;&gt;&gt; def documentCreated(event):
...     event.doc.created = datetime.datetime.utcnow()

&gt;&gt;&gt; from zope.component import adapter

&gt;&gt;&gt; &#64;adapter(IDocumentCreated)
... def documentCreated(event):
...     event.doc.created = datetime.datetime.utcnow()


&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; gsm.registerHandler(documentCreated, info='ng3')

&gt;&gt;&gt; reg_adapter = list(gsm.registeredHandlers())
&gt;&gt;&gt; 'ng3' in [x.info for x in reg_adapter]
True

&gt;&gt;&gt; gsm.registerHandler(documentCreated, name='ng4')
Traceback (most recent call last):
...
TypeError: Named handlers are not yet supported
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id97" id="registeredsubscriptionadapters" name="registeredsubscriptionadapters">8.43&nbsp;&nbsp;&nbsp;registeredSubscriptionAdapters</a></h2>
<p>Return an iterable of <cite>ISubscriptionAdapterRegistrations</cite>.  These
registrations describe the current subscription adapter registrations
in the object.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span> <span class="pre">-</span> <span class="pre">IComponentRegistry</span></tt></li>
<li>Signature: <cite>registeredSubscriptionAdapters()</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IValidate(Interface):
...     def validate(ob):
...         &quot;&quot;&quot;Determine whether the object is valid
...
...         Return a string describing a validation problem.
...         An empty string is returned to indicate that the
...         object is valid.
...         &quot;&quot;&quot;

&gt;&gt;&gt; class IDocument(Interface):
...     summary = Attribute(&quot;Document summary&quot;)
...     body = Attribute(&quot;Document text&quot;)

&gt;&gt;&gt; class Document(object):
...     implements(IDocument)
...     def __init__(self, summary, body):
...         self.summary, self.body = summary, body

&gt;&gt;&gt; from zope.component import adapts

&gt;&gt;&gt; class AdequateLength(object):
...
...     adapts(IDocument)
...     implements(IValidate)
...
...     def __init__(self, doc):
...         self.doc = doc
...
...     def validate(self):
...         if len(self.doc.body) &lt; 1000:
...             return 'too short'
...         else:
...             return ''

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; gsm.registerSubscriptionAdapter(AdequateLength, info='ng4')

&gt;&gt;&gt; reg_adapter = list(gsm.registeredSubscriptionAdapters())
&gt;&gt;&gt; 'ng4' in [x.info for x in reg_adapter]
True
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id98" id="registeredutilities" name="registeredutilities">8.44&nbsp;&nbsp;&nbsp;registeredUtilities</a></h2>
<p>Return an iterable of <cite>IUtilityRegistrations</cite> .  These registrations
describe the current utility registrations in the object.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span> <span class="pre">-</span> <span class="pre">IComponentRegistry</span></tt></li>
<li>Signature: <cite>registeredUtilities()</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IGreeter(Interface):
...     def greet(name):
...         &quot;say hello&quot;

&gt;&gt;&gt; class Greeter(object):
...
...     implements(IGreeter)
...
...     def greet(self, name):
...         print &quot;Hello&quot;, name

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; greet = Greeter()
&gt;&gt;&gt; gsm.registerUtility(greet, info='ng5')

&gt;&gt;&gt; reg_adapter = list(gsm.registeredUtilities())
&gt;&gt;&gt; 'ng5' in [x.info for x in reg_adapter]
True
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id99" id="registerhandler" name="registerhandler">8.45&nbsp;&nbsp;&nbsp;registerHandler</a></h2>
<p>Register a handler.  A handler is a subscriber that doesn't compute an
adapter but performs some function when called.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span> <span class="pre">-</span> <span class="pre">IComponentRegistry</span></tt></li>
<li>Signature: <cite>registerHandler(handler, required=None, name=u'', info='')</cite></li>
</ul>
</blockquote>
<p>In the current implementation of <tt class="docutils literal"><span class="pre">zope.component</span></tt> doesn't support
<cite>name</cite> attribute.</p>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; import datetime

&gt;&gt;&gt; def documentCreated(event):
...     event.doc.created = datetime.datetime.utcnow()

&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IDocumentCreated(Interface):
...     doc = Attribute(&quot;The document that was created&quot;)

&gt;&gt;&gt; class DocumentCreated(object):
...     implements(IDocumentCreated)
...
...     def __init__(self, doc):
...         self.doc = doc


&gt;&gt;&gt; def documentCreated(event):
...     event.doc.created = datetime.datetime.utcnow()

&gt;&gt;&gt; from zope.component import adapter

&gt;&gt;&gt; &#64;adapter(IDocumentCreated)
... def documentCreated(event):
...     event.doc.created = datetime.datetime.utcnow()


&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; gsm.registerHandler(documentCreated)

&gt;&gt;&gt; from zope.component import handle

&gt;&gt;&gt; handle(DocumentCreated(doc))
&gt;&gt;&gt; doc.created.__class__.__name__
'datetime'
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id100" id="registersubscriptionadapter" name="registersubscriptionadapter">8.46&nbsp;&nbsp;&nbsp;registerSubscriptionAdapter</a></h2>
<p>Register a subscriber factory.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span> <span class="pre">-</span> <span class="pre">IComponentRegistry</span></tt></li>
<li>Signature: <cite>registerSubscriptionAdapter(factory, required=None,
provides=None, name=u'', info='')</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IValidate(Interface):
...     def validate(ob):
...         &quot;&quot;&quot;Determine whether the object is valid
...
...         Return a string describing a validation problem.
...         An empty string is returned to indicate that the
...         object is valid.
...         &quot;&quot;&quot;

&gt;&gt;&gt; class IDocument(Interface):
...     summary = Attribute(&quot;Document summary&quot;)
...     body = Attribute(&quot;Document text&quot;)

&gt;&gt;&gt; class Document(object):
...     implements(IDocument)
...     def __init__(self, summary, body):
...         self.summary, self.body = summary, body

&gt;&gt;&gt; from zope.component import adapts

&gt;&gt;&gt; class AdequateLength(object):
...
...     adapts(IDocument)
...     implements(IValidate)
...
...     def __init__(self, doc):
...         self.doc = doc
...
...     def validate(self):
...         if len(self.doc.body) &lt; 1000:
...             return 'too short'
...         else:
...             return ''

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; gsm.registerSubscriptionAdapter(AdequateLength)
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id101" id="registerutility" name="registerutility">8.47&nbsp;&nbsp;&nbsp;registerUtility</a></h2>
<p>Register a utility.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span> <span class="pre">-</span> <span class="pre">IComponentRegistry</span></tt></li>
<li>Signature: <cite>registerUtility(component, provided=None, name=u'',
info=u'')</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IGreeter(Interface):
...     def greet(name):
...         &quot;say hello&quot;

&gt;&gt;&gt; class Greeter(object):
...
...     implements(IGreeter)
...
...     def greet(self, name):
...         print &quot;Hello&quot;, name

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; greet = Greeter()
&gt;&gt;&gt; gsm.registerUtility(greet)
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id102" id="subscribers" name="subscribers">8.48&nbsp;&nbsp;&nbsp;subscribers</a></h2>
<p>Get subscribers.  Subscribers are returned that provide the provided
interface and that depend on and are computed from the sequence of
required objects.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span> <span class="pre">-</span> <span class="pre">IComponentRegistry</span></tt></li>
<li>Signature: <cite>subscribers(required, provided, context=None)</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IValidate(Interface):
...     def validate(ob):
...         &quot;&quot;&quot;Determine whether the object is valid
...
...         Return a string describing a validation problem.
...         An empty string is returned to indicate that the
...         object is valid.
...         &quot;&quot;&quot;

&gt;&gt;&gt; class IDocument(Interface):
...     summary = Attribute(&quot;Document summary&quot;)
...     body = Attribute(&quot;Document text&quot;)

&gt;&gt;&gt; class Document(object):
...     implements(IDocument)
...     def __init__(self, summary, body):
...         self.summary, self.body = summary, body

&gt;&gt;&gt; from zope.component import adapts

&gt;&gt;&gt; class SingleLineSummary:
...     adapts(IDocument)
...     implements(IValidate)
...
...     def __init__(self, doc):
...         self.doc = doc
...
...     def validate(self):
...         if '\n' in self.doc.summary:
...             return 'Summary should only have one line'
...         else:
...             return ''

&gt;&gt;&gt; class AdequateLength(object):
...     adapts(IDocument)
...     implements(IValidate)
...
...     def __init__(self, doc):
...         self.doc = doc
...
...     def validate(self):
...         if len(self.doc.body) &lt; 1000:
...             return 'too short'
...         else:
...             return ''

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; gsm.registerSubscriptionAdapter(SingleLineSummary)
&gt;&gt;&gt; gsm.registerSubscriptionAdapter(AdequateLength)

&gt;&gt;&gt; from zope.component import subscribers

&gt;&gt;&gt; doc = Document(&quot;A\nDocument&quot;, &quot;blah&quot;)
&gt;&gt;&gt; [adapter.validate()
...  for adapter in subscribers([doc], IValidate)
...  if adapter.validate()]
['Summary should only have one line', 'too short']

&gt;&gt;&gt; doc = Document(&quot;A\nDocument&quot;, &quot;blah&quot; * 1000)
&gt;&gt;&gt; [adapter.validate()
...  for adapter in subscribers([doc], IValidate)
...  if adapter.validate()]
['Summary should only have one line']

&gt;&gt;&gt; doc = Document(&quot;A Document&quot;, &quot;blah&quot;)
&gt;&gt;&gt; [adapter.validate()
...  for adapter in subscribers([doc], IValidate)
...  if adapter.validate()]
['too short']
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id103" id="unregisteradapter" name="unregisteradapter">8.49&nbsp;&nbsp;&nbsp;unregisterAdapter</a></h2>
<p>Register an adapter factory.  A boolean is returned indicating whether
the registry was changed.  If the given component is None and there is
no component registered, or if the given component is not None and is
not registered, then the function returns False, otherwise it returns
True.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span> <span class="pre">-</span> <span class="pre">IComponentRegistry</span></tt></li>
<li>Signature: <cite>unregisterAdapter(factory=None, required=None,
provided=None, name=u'')</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import Interface

&gt;&gt;&gt; class IRegistrar(Interface):
...     &quot;&quot;&quot;A registrar will register object's details&quot;&quot;&quot;
...
...     def register():
...         &quot;&quot;&quot;Register object's details&quot;&quot;&quot;
...

&gt;&gt;&gt; from zope.interface import implements
&gt;&gt;&gt; from zope.component import adapts

&gt;&gt;&gt; class GuestRegistrarNG(object):
...
...     implements(IRegistrar)
...     adapts(IGuest)
...
...     def __init__(self, guest):
...         self.guest = guest
...
...     def register(self):
...         next_id = get_next_id()
...         guests_db[next_id] = {
...         'name': guest.name,
...         'place': guest.place,
...         'phone': guest.phone
...         }

&gt;&gt;&gt; class Guest(object):
...
...     implements(IGuest)
...
...     def __init__(self, name, place):
...         self.name = name
...         self.place = place

&gt;&gt;&gt; jack = Guest(&quot;Jack&quot;, &quot;Bangalore&quot;)
&gt;&gt;&gt; jack_registrar = GuestRegistrarNG(jack)

&gt;&gt;&gt; IRegistrar.providedBy(jack_registrar)
True

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()
&gt;&gt;&gt; gsm.registerAdapter(GuestRegistrarNG,
...                     (IGuest,), IRegistrar, 'ng6')

You can test it like this:

&gt;&gt;&gt; queryAdapter(jack, IRegistrar, 'ng6') #doctest: +ELLIPSIS
&lt;GuestRegistrarNG object at ...&gt;

Now unregister:

&gt;&gt;&gt; gsm.unregisterAdapter(GuestRegistrarNG, name='ng6')
True

After unregistration:

&gt;&gt;&gt; print queryAdapter(jack, IRegistrar, 'ng6')
None
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id104" id="unregisterhandler" name="unregisterhandler">8.50&nbsp;&nbsp;&nbsp;unregisterHandler</a></h2>
<p>Unregister a handler.  A handler is a subscriber that doesn't compute
an adapter but performs some function when called.  A boolean is
returned indicating whether the registry was changed.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span> <span class="pre">-</span> <span class="pre">IComponentRegistry</span></tt></li>
<li>Signature: <cite>unregisterHandler(handler=None, required=None,
name=u'')</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IDocument(Interface):
...
...     summary = Attribute(&quot;Document summary&quot;)
...     body = Attribute(&quot;Document text&quot;)

&gt;&gt;&gt; class Document(object):
...
...     implements(IDocument)
...     def __init__(self, summary, body):
...         self.summary, self.body = summary, body

&gt;&gt;&gt; doc = Document(&quot;A\nDocument&quot;, &quot;blah&quot;)

&gt;&gt;&gt; class IDocumentAccessed(Interface):
...     doc = Attribute(&quot;The document that was accessed&quot;)

&gt;&gt;&gt; class DocumentAccessed(object):
...     implements(IDocumentAccessed)
...
...     def __init__(self, doc):
...         self.doc = doc
...         self.doc.count = 0

&gt;&gt;&gt; from zope.component import adapter

&gt;&gt;&gt; &#64;adapter(IDocumentAccessed)
... def documentAccessed(event):
...     event.doc.count = event.doc.count + 1

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; gsm.registerHandler(documentAccessed)

&gt;&gt;&gt; from zope.component import handle

&gt;&gt;&gt; handle(DocumentAccessed(doc))
&gt;&gt;&gt; doc.count
1

Now unregister:

&gt;&gt;&gt; gsm.unregisterHandler(documentAccessed)
True

After unregistration:

&gt;&gt;&gt; handle(DocumentAccessed(doc))
&gt;&gt;&gt; doc.count
0
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id105" id="unregistersubscriptionadapter" name="unregistersubscriptionadapter">8.51&nbsp;&nbsp;&nbsp;unregisterSubscriptionAdapter</a></h2>
<p>Unregister a subscriber factory.  A boolean is returned indicating
whether the registry was changed.  If the given component is None and
there is no component registered, or if the given component is not
None and is not registered, then the function returns False, otherwise
it returns True.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span> <span class="pre">-</span> <span class="pre">IComponentRegistry</span></tt></li>
<li>Signature: <cite>unregisterSubscriptionAdapter(factory=None,
required=None, provides=None, name=u'')</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import Attribute
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IValidate(Interface):
...     def validate(ob):
...         &quot;&quot;&quot;Determine whether the object is valid
...
...         Return a string describing a validation problem.
...         An empty string is returned to indicate that the
...         object is valid.
...         &quot;&quot;&quot;

&gt;&gt;&gt; class IDocument(Interface):
...     summary = Attribute(&quot;Document summary&quot;)
...     body = Attribute(&quot;Document text&quot;)

&gt;&gt;&gt; class Document(object):
...     implements(IDocument)
...     def __init__(self, summary, body):
...         self.summary, self.body = summary, body

&gt;&gt;&gt; from zope.component import adapts

&gt;&gt;&gt; class AdequateLength(object):
...
...     adapts(IDocument)
...     implements(IValidate)
...
...     def __init__(self, doc):
...         self.doc = doc
...
...     def validate(self):
...         if len(self.doc.body) &lt; 1000:
...             return 'too short'
...         else:
...             return ''

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; gsm.registerSubscriptionAdapter(AdequateLength)

&gt;&gt;&gt; from zope.component import subscribers

&gt;&gt;&gt; doc = Document(&quot;A\nDocument&quot;, &quot;blah&quot;)
&gt;&gt;&gt; [adapter.validate()
...  for adapter in subscribers([doc], IValidate)
...  if adapter.validate()]
['too short']

Now unregister:

&gt;&gt;&gt; gsm.unregisterSubscriptionAdapter(AdequateLength)
True

After unregistration:

&gt;&gt;&gt; [adapter.validate()
...  for adapter in subscribers([doc], IValidate)
...  if adapter.validate()]
[]
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id106" id="unregisterutility" name="unregisterutility">8.52&nbsp;&nbsp;&nbsp;unregisterUtility</a></h2>
<p>Unregister a utility.  A boolean is returned indicating whether the
registry was changed.  If the given component is None and there is no
component registered, or if the given component is not None and is not
registered, then the function returns False, otherwise it returns
True.</p>
<blockquote>
<ul class="simple">
<li>Location: <tt class="docutils literal"><span class="pre">zope.component</span> <span class="pre">-</span> <span class="pre">IComponentRegistry</span></tt></li>
<li>Signature: <cite>unregisterUtility(component=None, provided=None,
name=u'')</cite></li>
</ul>
</blockquote>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from zope.interface import Interface
&gt;&gt;&gt; from zope.interface import implements

&gt;&gt;&gt; class IGreeter(Interface):
...     def greet(name):
...         &quot;say hello&quot;

&gt;&gt;&gt; class Greeter(object):
...
...     implements(IGreeter)
...
...     def greet(self, name):
...         return &quot;Hello &quot; + name

&gt;&gt;&gt; from zope.component import getGlobalSiteManager
&gt;&gt;&gt; gsm = getGlobalSiteManager()

&gt;&gt;&gt; greet = Greeter()
&gt;&gt;&gt; gsm.registerUtility(greet)

&gt;&gt;&gt; queryUtility(IGreeter).greet('Jack')
'Hello Jack'

Now unregister:

&gt;&gt;&gt; gsm.unregisterUtility(greet)
True

After unregistration:

&gt;&gt;&gt; print queryUtility(IGreeter)
None
</pre>
</div>
</div>
</div>
</body>
</html>
